# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _TopClass.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TopClass', [dirname(__file__)])
        except ImportError:
            import _TopClass
            return _TopClass
        if fp is not None:
            try:
                _mod = imp.load_module('_TopClass', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _TopClass = swig_import_helper()
    del swig_import_helper
else:
    import _TopClass
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TopClass.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_TopClass.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_TopClass.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_TopClass.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_TopClass.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_TopClass.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_TopClass.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_TopClass.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_TopClass.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_TopClass.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_TopClass.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_TopClass.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_TopClass.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_TopClass.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_TopClass.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_TopClass.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_TopClass.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _TopClass.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.gp
import OCC.Standard
import OCC.TopoDS
import OCC.MMgt
import OCC.TCollection
import OCC.TopLoc
import OCC.TopAbs
import OCC.IntCurveSurface
import OCC.math
import OCC.Adaptor3d
import OCC.GeomAbs
import OCC.TColStd
import OCC.Geom
import OCC.TColgp
import OCC.Adaptor2d
import OCC.Geom2d
import OCC.Intf
import OCC.Bnd
import OCC.IntSurf
class TopClass_Intersection3d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Perform(self, *args):
        """
        * Perform the intersection between the segment L(0) ... L(Prm) and the Face <Face>.  Only the point with the smallest parameter on the line is returned.  The Tolerance <Tol> is used to determine if the first point of the segment is near the face. In that case, the parameter of the intersection point on the line can be a negative value (greater than -Tol).

        :param L:
        :type L: gp_Lin
        :param Prm:
        :type Prm: float
        :param Tol:
        :type Tol: float
        :param Face:
        :type Face: TopoDS_Face &
        :rtype: void

        """
        return _TopClass.TopClass_Intersection3d_Perform(self, *args)


    def IsDone(self, *args):
        """
        * True is returned when the intersection have been computed.

        :rtype: bool

        """
        return _TopClass.TopClass_Intersection3d_IsDone(self, *args)


    def HasAPoint(self, *args):
        """
        * True is returned if a point has been found.

        :rtype: bool

        """
        return _TopClass.TopClass_Intersection3d_HasAPoint(self, *args)


    def Point(self, *args):
        """
        * Returns the Intersection Point.

        :rtype: IntCurveSurface_IntersectionPoint

        """
        return _TopClass.TopClass_Intersection3d_Point(self, *args)


    def State(self, *args):
        """
        * Returns the state of the point on the face. The values can be either TopAbs_IN ( the point is in the face) or TopAbs_ON ( the point is on a boudary of the face).

        :rtype: TopAbs_State

        """
        return _TopClass.TopClass_Intersection3d_State(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


TopClass_Intersection3d.Perform = new_instancemethod(_TopClass.TopClass_Intersection3d_Perform, None, TopClass_Intersection3d)
TopClass_Intersection3d.IsDone = new_instancemethod(_TopClass.TopClass_Intersection3d_IsDone, None, TopClass_Intersection3d)
TopClass_Intersection3d.HasAPoint = new_instancemethod(_TopClass.TopClass_Intersection3d_HasAPoint, None, TopClass_Intersection3d)
TopClass_Intersection3d.Point = new_instancemethod(_TopClass.TopClass_Intersection3d_Point, None, TopClass_Intersection3d)
TopClass_Intersection3d.State = new_instancemethod(_TopClass.TopClass_Intersection3d_State, None, TopClass_Intersection3d)
TopClass_Intersection3d._kill_pointed = new_instancemethod(_TopClass.TopClass_Intersection3d__kill_pointed, None, TopClass_Intersection3d)
TopClass_Intersection3d_swigregister = _TopClass.TopClass_Intersection3d_swigregister
TopClass_Intersection3d_swigregister(TopClass_Intersection3d)

class TopClass_SolidExplorer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Reject(self, *args):
        """
        * Should return True if the point is outside a bounding volume of the shape.

        :param P:
        :type P: gp_Pnt
        :rtype: bool

        """
        return _TopClass.TopClass_SolidExplorer_Reject(self, *args)


    def Segment(self, *args):
        """
        * Returns in <L>, <Par> a segment having at least one intersection with the shape boundary to compute intersections.

        :param P:
        :type P: gp_Pnt
        :param L:
        :type L: gp_Lin
        :param Par:
        :type Par: float &
        :rtype: void

        """
        return _TopClass.TopClass_SolidExplorer_Segment(self, *args)


    def OtherSegment(self, *args):
        """
        * Returns in <L>, <Par> a segment having at least one intersection with the shape boundary to compute intersections.  The First Call to this method returns a line which point to a point of the first face of the shape. The Second Call provide a line to the second face and so on.  if the method is called N times on a shape with F faces (N>F) the line point to other points on the face 1,2,3 ... N

        :param P:
        :type P: gp_Pnt
        :param L:
        :type L: gp_Lin
        :param Par:
        :type Par: float &
        :rtype: void

        """
        return _TopClass.TopClass_SolidExplorer_OtherSegment(self, *args)


    def InitShell(self, *args):
        """
        * Starts an exploration of the shells.

        :rtype: void

        """
        return _TopClass.TopClass_SolidExplorer_InitShell(self, *args)


    def MoreShells(self, *args):
        """
        * Returns True if there is a current shell.

        :rtype: bool

        """
        return _TopClass.TopClass_SolidExplorer_MoreShells(self, *args)


    def NextShell(self, *args):
        """
        * Sets the explorer to the next shell and returns False if there are no more wires.

        :rtype: void

        """
        return _TopClass.TopClass_SolidExplorer_NextShell(self, *args)


    def RejectShell(self, *args):
        """
        * Returns True if the shell bounding volume does not intersect the segment.

        :param L:
        :type L: gp_Lin
        :param Par:
        :type Par: float
        :rtype: bool

        """
        return _TopClass.TopClass_SolidExplorer_RejectShell(self, *args)


    def InitFace(self, *args):
        """
        * Starts an exploration of the faces.

        :rtype: void

        """
        return _TopClass.TopClass_SolidExplorer_InitFace(self, *args)


    def MoreFaces(self, *args):
        """
        * Returns True if there is a current face.

        :rtype: bool

        """
        return _TopClass.TopClass_SolidExplorer_MoreFaces(self, *args)


    def NextFace(self, *args):
        """
        * Sets the explorer to the next face and returns False if there are no more wires.

        :rtype: void

        """
        return _TopClass.TopClass_SolidExplorer_NextFace(self, *args)


    def CurrentFace(self, *args):
        """
        * Returns the current face.

        :rtype: TopoDS_Face

        """
        return _TopClass.TopClass_SolidExplorer_CurrentFace(self, *args)


    def RejectFace(self, *args):
        """
        * Returns True if the face bounding volume does not intersect the segment.

        :param L:
        :type L: gp_Lin
        :param Par:
        :type Par: float
        :rtype: bool

        """
        return _TopClass.TopClass_SolidExplorer_RejectFace(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


TopClass_SolidExplorer.Reject = new_instancemethod(_TopClass.TopClass_SolidExplorer_Reject, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.Segment = new_instancemethod(_TopClass.TopClass_SolidExplorer_Segment, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.OtherSegment = new_instancemethod(_TopClass.TopClass_SolidExplorer_OtherSegment, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.InitShell = new_instancemethod(_TopClass.TopClass_SolidExplorer_InitShell, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.MoreShells = new_instancemethod(_TopClass.TopClass_SolidExplorer_MoreShells, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.NextShell = new_instancemethod(_TopClass.TopClass_SolidExplorer_NextShell, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.RejectShell = new_instancemethod(_TopClass.TopClass_SolidExplorer_RejectShell, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.InitFace = new_instancemethod(_TopClass.TopClass_SolidExplorer_InitFace, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.MoreFaces = new_instancemethod(_TopClass.TopClass_SolidExplorer_MoreFaces, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.NextFace = new_instancemethod(_TopClass.TopClass_SolidExplorer_NextFace, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.CurrentFace = new_instancemethod(_TopClass.TopClass_SolidExplorer_CurrentFace, None, TopClass_SolidExplorer)
TopClass_SolidExplorer.RejectFace = new_instancemethod(_TopClass.TopClass_SolidExplorer_RejectFace, None, TopClass_SolidExplorer)
TopClass_SolidExplorer._kill_pointed = new_instancemethod(_TopClass.TopClass_SolidExplorer__kill_pointed, None, TopClass_SolidExplorer)
TopClass_SolidExplorer_swigregister = _TopClass.TopClass_SolidExplorer_swigregister
TopClass_SolidExplorer_swigregister(TopClass_SolidExplorer)



