# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _BSplSLib.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BSplSLib', [dirname(__file__)])
        except ImportError:
            import _BSplSLib
            return _BSplSLib
        if fp is not None:
            try:
                _mod = imp.load_module('_BSplSLib', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _BSplSLib = swig_import_helper()
    del swig_import_helper
else:
    import _BSplSLib
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BSplSLib.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_BSplSLib.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BSplSLib.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BSplSLib.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BSplSLib.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BSplSLib.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BSplSLib.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BSplSLib.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BSplSLib.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BSplSLib.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BSplSLib.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BSplSLib.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BSplSLib.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BSplSLib.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BSplSLib.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BSplSLib.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BSplSLib.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _BSplSLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.Standard
import OCC.TColgp
import OCC.gp
import OCC.TCollection
import OCC.MMgt
import OCC.TColStd
class bsplslib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def RationalDerivative(*args):
        """
        * this is a one dimensional function typedef void (*EvaluatorFunction) ( Standard_Integer // Derivative Request Standard_Real * // StartEnd[2][2]  // [0] = U  // [1] = V  // [0] = start  // [1] = end Standard_Real // UParameter Standard_Real // VParamerer Standard_Real & // Result Standard_Integer &) ;// Error Code serves to multiply a given vectorial BSpline by a function Computes the derivatives of a ratio of two-variables functions x(u,v) / w(u,v) at orders <N,M>, x(u,v) is a vector in dimension <3>.  <Ders> is an array containing the values of the input derivatives from 0 to Min(<N>,<UDeg>), 0 to Min(<M>,<VDeg>). For orders higher than <UDeg,VDeg> the input derivatives are assumed to be 0.  The <Ders> is a 2d array and the dimension of the lines is always (<VDeg>+1) * (<3>+1), even if <N> is smaller than <Udeg> (the derivatives higher than <N> are not used).  Content of <Ders> :  x(i,j)[k] means : the composant k of x derivated (i) times in u and (j) times in v.  ... First line ...  x[1],x[2],...,x[3],w x(0,1)[1],...,x(0,1)[3],w(1,0) ... x(0,VDeg)[1],...,x(0,VDeg)[3],w(0,VDeg)  ... Then second line ...  x(1,0)[1],...,x(1,0)[3],w(1,0) x(1,1)[1],...,x(1,1)[3],w(1,1) ... x(1,VDeg)[1],...,x(1,VDeg)[3],w(1,VDeg)  ...  ... Last line ...  x(UDeg,0)[1],...,x(UDeg,0)[3],w(UDeg,0) x(UDeg,1)[1],...,x(UDeg,1)[3],w(UDeg,1) ... x(Udeg,VDeg)[1],...,x(UDeg,VDeg)[3],w(Udeg,VDeg) If <All> is false, only the derivative at order <N,M> is computed. <RDers> is an array of length 3 which will contain the result :  x(1)/w , x(2)/w , ... derivated <N> <M> times  If <All> is true multiples derivatives are computed. All the derivatives (i,j) with 0 <= i+j <= Max(N,M) are computed. <RDers> is an array of length 3 * (<N>+1) * (<M>+1) which will contains :  x(1)/w , x(2)/w , ... x(1)/w , x(2)/w , ... derivated <0,1> times x(1)/w , x(2)/w , ... derivated <0,2> times ... x(1)/w , x(2)/w , ... derivated <0,N> times  x(1)/w , x(2)/w , ... derivated <1,0> times x(1)/w , x(2)/w , ... derivated <1,1> times ... x(1)/w , x(2)/w , ... derivated <1,N> times  x(1)/w , x(2)/w , ... derivated <N,0> times .... Warning: <RDers> must be dimensionned properly.

        :param UDeg:
        :type UDeg: int
        :param VDeg:
        :type VDeg: int
        :param N:
        :type N: int
        :param M:
        :type M: int
        :param Ders:
        :type Ders: float &
        :param RDers:
        :type RDers: float &
        :param All: default value is Standard_True
        :type All: bool
        :rtype: void

        """
        return _BSplSLib.bsplslib_RationalDerivative(*args)

    RationalDerivative = staticmethod(RationalDerivative)

    def D0(*args):
        """
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param UIndex:
        :type UIndex: int
        :param VIndex:
        :type VIndex: int
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UKnots:
        :type UKnots: TColStd_Array1OfReal &
        :param VKnots:
        :type VKnots: TColStd_Array1OfReal &
        :param UMults:
        :type UMults: TColStd_Array1OfInteger &
        :param VMults:
        :type VMults: TColStd_Array1OfInteger &
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param URat:
        :type URat: bool
        :param VRat:
        :type VRat: bool
        :param UPer:
        :type UPer: bool
        :param VPer:
        :type VPer: bool
        :param P:
        :type P: gp_Pnt
        :rtype: void

        """
        return _BSplSLib.bsplslib_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param UIndex:
        :type UIndex: int
        :param VIndex:
        :type VIndex: int
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UKnots:
        :type UKnots: TColStd_Array1OfReal &
        :param VKnots:
        :type VKnots: TColStd_Array1OfReal &
        :param UMults:
        :type UMults: TColStd_Array1OfInteger &
        :param VMults:
        :type VMults: TColStd_Array1OfInteger &
        :param Degree:
        :type Degree: int
        :param VDegree:
        :type VDegree: int
        :param URat:
        :type URat: bool
        :param VRat:
        :type VRat: bool
        :param UPer:
        :type UPer: bool
        :param VPer:
        :type VPer: bool
        :param P:
        :type P: gp_Pnt
        :param Vu:
        :type Vu: gp_Vec
        :param Vv:
        :type Vv: gp_Vec
        :rtype: void

        """
        return _BSplSLib.bsplslib_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param UIndex:
        :type UIndex: int
        :param VIndex:
        :type VIndex: int
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UKnots:
        :type UKnots: TColStd_Array1OfReal &
        :param VKnots:
        :type VKnots: TColStd_Array1OfReal &
        :param UMults:
        :type UMults: TColStd_Array1OfInteger &
        :param VMults:
        :type VMults: TColStd_Array1OfInteger &
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param URat:
        :type URat: bool
        :param VRat:
        :type VRat: bool
        :param UPer:
        :type UPer: bool
        :param VPer:
        :type VPer: bool
        :param P:
        :type P: gp_Pnt
        :param Vu:
        :type Vu: gp_Vec
        :param Vv:
        :type Vv: gp_Vec
        :param Vuu:
        :type Vuu: gp_Vec
        :param Vvv:
        :type Vvv: gp_Vec
        :param Vuv:
        :type Vuv: gp_Vec
        :rtype: void

        """
        return _BSplSLib.bsplslib_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param UIndex:
        :type UIndex: int
        :param VIndex:
        :type VIndex: int
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UKnots:
        :type UKnots: TColStd_Array1OfReal &
        :param VKnots:
        :type VKnots: TColStd_Array1OfReal &
        :param UMults:
        :type UMults: TColStd_Array1OfInteger &
        :param VMults:
        :type VMults: TColStd_Array1OfInteger &
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param URat:
        :type URat: bool
        :param VRat:
        :type VRat: bool
        :param UPer:
        :type UPer: bool
        :param VPer:
        :type VPer: bool
        :param P:
        :type P: gp_Pnt
        :param Vu:
        :type Vu: gp_Vec
        :param Vv:
        :type Vv: gp_Vec
        :param Vuu:
        :type Vuu: gp_Vec
        :param Vvv:
        :type Vvv: gp_Vec
        :param Vuv:
        :type Vuv: gp_Vec
        :param Vuuu:
        :type Vuuu: gp_Vec
        :param Vvvv:
        :type Vvvv: gp_Vec
        :param Vuuv:
        :type Vuuv: gp_Vec
        :param Vuvv:
        :type Vuvv: gp_Vec
        :rtype: void

        """
        return _BSplSLib.bsplslib_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param Nu:
        :type Nu: int
        :param Nv:
        :type Nv: int
        :param UIndex:
        :type UIndex: int
        :param VIndex:
        :type VIndex: int
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UKnots:
        :type UKnots: TColStd_Array1OfReal &
        :param VKnots:
        :type VKnots: TColStd_Array1OfReal &
        :param UMults:
        :type UMults: TColStd_Array1OfInteger &
        :param VMults:
        :type VMults: TColStd_Array1OfInteger &
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param URat:
        :type URat: bool
        :param VRat:
        :type VRat: bool
        :param UPer:
        :type UPer: bool
        :param VPer:
        :type VPer: bool
        :param Vn:
        :type Vn: gp_Vec
        :rtype: void

        """
        return _BSplSLib.bsplslib_DN(*args)

    DN = staticmethod(DN)

    def Iso(*args):
        """
        * Computes the poles and weights of an isoparametric curve at parameter <Param> (UIso if <IsU> is True, VIso else).

        :param Param:
        :type Param: float
        :param IsU:
        :type IsU: bool
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Knots:
        :type Knots: TColStd_Array1OfReal &
        :param Mults:
        :type Mults: TColStd_Array1OfInteger &
        :param Degree:
        :type Degree: int
        :param Periodic:
        :type Periodic: bool
        :param CPoles:
        :type CPoles: TColgp_Array1OfPnt
        :param CWeights:
        :type CWeights: TColStd_Array1OfReal &
        :rtype: void

        """
        return _BSplSLib.bsplslib_Iso(*args)

    Iso = staticmethod(Iso)

    def HomogeneousD0(*args):
        """
        * Makes an homogeneous evaluation of Poles and Weights any and returns in P the Numerator value and in W the Denominator value if Weights are present otherwise returns 1.0e0

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param UIndex:
        :type UIndex: int
        :param VIndex:
        :type VIndex: int
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UKnots:
        :type UKnots: TColStd_Array1OfReal &
        :param VKnots:
        :type VKnots: TColStd_Array1OfReal &
        :param UMults:
        :type UMults: TColStd_Array1OfInteger &
        :param VMults:
        :type VMults: TColStd_Array1OfInteger &
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param URat:
        :type URat: bool
        :param VRat:
        :type VRat: bool
        :param UPer:
        :type UPer: bool
        :param VPer:
        :type VPer: bool
        :param W:
        :type W: float &
        :param P:
        :type P: gp_Pnt
        :rtype: void

        """
        return _BSplSLib.bsplslib_HomogeneousD0(*args)

    HomogeneousD0 = staticmethod(HomogeneousD0)

    def HomogeneousD1(*args):
        """
        * Makes an homogeneous evaluation of Poles and Weights any and returns in P the Numerator value and in W the Denominator value if Weights are present otherwise returns 1.0e0

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param UIndex:
        :type UIndex: int
        :param VIndex:
        :type VIndex: int
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UKnots:
        :type UKnots: TColStd_Array1OfReal &
        :param VKnots:
        :type VKnots: TColStd_Array1OfReal &
        :param UMults:
        :type UMults: TColStd_Array1OfInteger &
        :param VMults:
        :type VMults: TColStd_Array1OfInteger &
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param URat:
        :type URat: bool
        :param VRat:
        :type VRat: bool
        :param UPer:
        :type UPer: bool
        :param VPer:
        :type VPer: bool
        :param N:
        :type N: gp_Pnt
        :param Nu:
        :type Nu: gp_Vec
        :param Nv:
        :type Nv: gp_Vec
        :param D:
        :type D: float &
        :param Du:
        :type Du: float &
        :param Dv:
        :type Dv: float &
        :rtype: void

        """
        return _BSplSLib.bsplslib_HomogeneousD1(*args)

    HomogeneousD1 = staticmethod(HomogeneousD1)

    def Reverse(*args):
        """
        * Reverses the array of poles. Last is the Index of the new first Row( Col) of Poles. On a non periodic surface Last is  Poles.Upper(). On a periodic curve last is  (number of flat knots - degree - 1) or  (sum of multiplicities(but for the last) + degree - 1)

        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Last:
        :type Last: int
        :param UDirection:
        :type UDirection: bool
        :rtype: void

        * Reverses the array of weights.

        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Last:
        :type Last: int
        :param UDirection:
        :type UDirection: bool
        :rtype: void

        """
        return _BSplSLib.bsplslib_Reverse(*args)

    Reverse = staticmethod(Reverse)

    def IsRational(*args):
        """
        * Returns False if all the weights of the array <Weights> in the area [I1,I2] * [J1,J2] are identic. Epsilon is used for comparing weights. If Epsilon is 0. the Epsilon of the first weight is used.

        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param I1:
        :type I1: int
        :param I2:
        :type I2: int
        :param J1:
        :type J1: int
        :param J2:
        :type J2: int
        :param Epsilon: default value is 0.0
        :type Epsilon: float
        :rtype: bool

        """
        return _BSplSLib.bsplslib_IsRational(*args)

    IsRational = staticmethod(IsRational)

    def SetPoles(*args):
        """
        * Copy in FP the coordinates of the poles.

        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param FP:
        :type FP: TColStd_Array1OfReal &
        :param UDirection:
        :type UDirection: bool
        :rtype: void

        * Copy in FP the coordinates of the poles.

        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param FP:
        :type FP: TColStd_Array1OfReal &
        :param UDirection:
        :type UDirection: bool
        :rtype: void

        """
        return _BSplSLib.bsplslib_SetPoles(*args)

    SetPoles = staticmethod(SetPoles)

    def GetPoles(*args):
        """
        * Get from FP the coordinates of the poles.

        :param FP:
        :type FP: TColStd_Array1OfReal &
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param UDirection:
        :type UDirection: bool
        :rtype: void

        * Get from FP the coordinates of the poles.

        :param FP:
        :type FP: TColStd_Array1OfReal &
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UDirection:
        :type UDirection: bool
        :rtype: void

        """
        return _BSplSLib.bsplslib_GetPoles(*args)

    GetPoles = staticmethod(GetPoles)

    def MovePoint(*args):
        """
        * Find the new poles which allows an old point (with a given u,v as parameters) to reach a new position UIndex1,UIndex2 indicate the range of poles we can move for U (1, UNbPoles-1) or (2, UNbPoles) -> no constraint for one side in U (2, UNbPoles-1) -> the ends are enforced for U don't enter (1,NbPoles) and (1,VNbPoles) -> error: rigid move if problem in BSplineBasis calculation, no change for the curve and UFirstIndex, VLastIndex = 0 VFirstIndex, VLastIndex = 0

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param Displ:
        :type Displ: gp_Vec
        :param UIndex1:
        :type UIndex1: int
        :param UIndex2:
        :type UIndex2: int
        :param VIndex1:
        :type VIndex1: int
        :param VIndex2:
        :type VIndex2: int
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param Rational:
        :type Rational: bool
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UFlatKnots:
        :type UFlatKnots: TColStd_Array1OfReal &
        :param VFlatKnots:
        :type VFlatKnots: TColStd_Array1OfReal &
        :param UFirstIndex:
        :type UFirstIndex: int &
        :param ULastIndex:
        :type ULastIndex: int &
        :param VFirstIndex:
        :type VFirstIndex: int &
        :param VLastIndex:
        :type VLastIndex: int &
        :param NewPoles:
        :type NewPoles: TColgp_Array2OfPnt
        :rtype: void

        """
        return _BSplSLib.bsplslib_MovePoint(*args)

    MovePoint = staticmethod(MovePoint)

    def InsertKnots(*args):
        """
        :param UDirection:
        :type UDirection: bool
        :param Degree:
        :type Degree: int
        :param Periodic:
        :type Periodic: bool
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Knots:
        :type Knots: TColStd_Array1OfReal &
        :param Mults:
        :type Mults: TColStd_Array1OfInteger &
        :param AddKnots:
        :type AddKnots: TColStd_Array1OfReal &
        :param AddMults:
        :type AddMults: TColStd_Array1OfInteger &
        :param NewPoles:
        :type NewPoles: TColgp_Array2OfPnt
        :param NewWeights:
        :type NewWeights: TColStd_Array2OfReal &
        :param NewKnots:
        :type NewKnots: TColStd_Array1OfReal &
        :param NewMults:
        :type NewMults: TColStd_Array1OfInteger &
        :param Epsilon:
        :type Epsilon: float
        :param Add: default value is Standard_True
        :type Add: bool
        :rtype: void

        """
        return _BSplSLib.bsplslib_InsertKnots(*args)

    InsertKnots = staticmethod(InsertKnots)

    def RemoveKnot(*args):
        """
        :param UDirection:
        :type UDirection: bool
        :param Index:
        :type Index: int
        :param Mult:
        :type Mult: int
        :param Degree:
        :type Degree: int
        :param Periodic:
        :type Periodic: bool
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Knots:
        :type Knots: TColStd_Array1OfReal &
        :param Mults:
        :type Mults: TColStd_Array1OfInteger &
        :param NewPoles:
        :type NewPoles: TColgp_Array2OfPnt
        :param NewWeights:
        :type NewWeights: TColStd_Array2OfReal &
        :param NewKnots:
        :type NewKnots: TColStd_Array1OfReal &
        :param NewMults:
        :type NewMults: TColStd_Array1OfInteger &
        :param Tolerance:
        :type Tolerance: float
        :rtype: bool

        """
        return _BSplSLib.bsplslib_RemoveKnot(*args)

    RemoveKnot = staticmethod(RemoveKnot)

    def IncreaseDegree(*args):
        """
        :param UDirection:
        :type UDirection: bool
        :param Degree:
        :type Degree: int
        :param NewDegree:
        :type NewDegree: int
        :param Periodic:
        :type Periodic: bool
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Knots:
        :type Knots: TColStd_Array1OfReal &
        :param Mults:
        :type Mults: TColStd_Array1OfInteger &
        :param NewPoles:
        :type NewPoles: TColgp_Array2OfPnt
        :param NewWeights:
        :type NewWeights: TColStd_Array2OfReal &
        :param NewKnots:
        :type NewKnots: TColStd_Array1OfReal &
        :param NewMults:
        :type NewMults: TColStd_Array1OfInteger &
        :rtype: void

        """
        return _BSplSLib.bsplslib_IncreaseDegree(*args)

    IncreaseDegree = staticmethod(IncreaseDegree)

    def Unperiodize(*args):
        """
        :param UDirection:
        :type UDirection: bool
        :param Degree:
        :type Degree: int
        :param Mults:
        :type Mults: TColStd_Array1OfInteger &
        :param Knots:
        :type Knots: TColStd_Array1OfReal &
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param NewMults:
        :type NewMults: TColStd_Array1OfInteger &
        :param NewKnots:
        :type NewKnots: TColStd_Array1OfReal &
        :param NewPoles:
        :type NewPoles: TColgp_Array2OfPnt
        :param NewWeights:
        :type NewWeights: TColStd_Array2OfReal &
        :rtype: void

        """
        return _BSplSLib.bsplslib_Unperiodize(*args)

    Unperiodize = staticmethod(Unperiodize)

    def NoWeights(*args):
        """
        * Used as argument for a non rational curve.

        :rtype: TColStd_Array2OfReal

        """
        return _BSplSLib.bsplslib_NoWeights(*args)

    NoWeights = staticmethod(NoWeights)

    def BuildCache(*args):
        """
        * Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param USpanDomain:
        :type USpanDomain: float
        :param VSpanDomain:
        :type VSpanDomain: float
        :param UPeriodicFlag:
        :type UPeriodicFlag: bool
        :param VPeriodicFlag:
        :type VPeriodicFlag: bool
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param UIndex:
        :type UIndex: int
        :param VIndex:
        :type VIndex: int
        :param UFlatKnots:
        :type UFlatKnots: TColStd_Array1OfReal &
        :param VFlatKnots:
        :type VFlatKnots: TColStd_Array1OfReal &
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param CachePoles:
        :type CachePoles: TColgp_Array2OfPnt
        :param CacheWeights:
        :type CacheWeights: TColStd_Array2OfReal &
        :rtype: void

        """
        return _BSplSLib.bsplslib_BuildCache(*args)

    BuildCache = staticmethod(BuildCache)

    def CacheD0(*args):
        """
        * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param UCacheParameter:
        :type UCacheParameter: float
        :param VCacheParameter:
        :type VCacheParameter: float
        :param USpanLenght:
        :type USpanLenght: float
        :param VSpanLength:
        :type VSpanLength: float
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Point:
        :type Point: gp_Pnt
        :rtype: void

        """
        return _BSplSLib.bsplslib_CacheD0(*args)

    CacheD0 = staticmethod(CacheD0)

    def CoefsD0(*args):
        """
        * Calls CacheD0 for Bezier Surfaces Arrays computed with the method PolesCoefficients. Warning: To be used for BezierSurfaces ONLY!!!

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Point:
        :type Point: gp_Pnt
        :rtype: void

        """
        return _BSplSLib.bsplslib_CoefsD0(*args)

    CoefsD0 = staticmethod(CoefsD0)

    def CacheD1(*args):
        """
        * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param UCacheParameter:
        :type UCacheParameter: float
        :param VCacheParameter:
        :type VCacheParameter: float
        :param USpanLenght:
        :type USpanLenght: float
        :param VSpanLength:
        :type VSpanLength: float
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Point:
        :type Point: gp_Pnt
        :param VecU:
        :type VecU: gp_Vec
        :param VecV:
        :type VecV: gp_Vec
        :rtype: void

        """
        return _BSplSLib.bsplslib_CacheD1(*args)

    CacheD1 = staticmethod(CacheD1)

    def CoefsD1(*args):
        """
        * Calls CacheD0 for Bezier Surfaces Arrays computed with the method PolesCoefficients. Warning: To be used for BezierSurfaces ONLY!!!

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Point:
        :type Point: gp_Pnt
        :param VecU:
        :type VecU: gp_Vec
        :param VecV:
        :type VecV: gp_Vec
        :rtype: void

        """
        return _BSplSLib.bsplslib_CoefsD1(*args)

    CoefsD1 = staticmethod(CoefsD1)

    def CacheD2(*args):
        """
        * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param UCacheParameter:
        :type UCacheParameter: float
        :param VCacheParameter:
        :type VCacheParameter: float
        :param USpanLenght:
        :type USpanLenght: float
        :param VSpanLength:
        :type VSpanLength: float
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Point:
        :type Point: gp_Pnt
        :param VecU:
        :type VecU: gp_Vec
        :param VecV:
        :type VecV: gp_Vec
        :param VecUU:
        :type VecUU: gp_Vec
        :param VecUV:
        :type VecUV: gp_Vec
        :param VecVV:
        :type VecVV: gp_Vec
        :rtype: void

        """
        return _BSplSLib.bsplslib_CacheD2(*args)

    CacheD2 = staticmethod(CacheD2)

    def CoefsD2(*args):
        """
        * Calls CacheD0 for Bezier Surfaces Arrays computed with the method PolesCoefficients. Warning: To be used for BezierSurfaces ONLY!!!

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param Point:
        :type Point: gp_Pnt
        :param VecU:
        :type VecU: gp_Vec
        :param VecV:
        :type VecV: gp_Vec
        :param VecUU:
        :type VecUU: gp_Vec
        :param VecUV:
        :type VecUV: gp_Vec
        :param VecVV:
        :type VecVV: gp_Vec
        :rtype: void

        """
        return _BSplSLib.bsplslib_CoefsD2(*args)

    CoefsD2 = staticmethod(CoefsD2)

    def PolesCoefficients(*args):
        """
        * Warning! To be used for BezierSurfaces ONLY!!!

        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param CachePoles:
        :type CachePoles: TColgp_Array2OfPnt
        :rtype: void

        * Encapsulation of BuildCache to perform the evaluation of the Taylor expansion for beziersurfaces at parameters 0.,0.; Warning: To be used for BezierSurfaces ONLY!!!

        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param CachePoles:
        :type CachePoles: TColgp_Array2OfPnt
        :param CacheWeights:
        :type CacheWeights: TColStd_Array2OfReal &
        :rtype: void

        """
        return _BSplSLib.bsplslib_PolesCoefficients(*args)

    PolesCoefficients = staticmethod(PolesCoefficients)

    def Resolution(*args):
        """
        * Given a tolerance in 3D space returns two tolerances, one in U one in V such that for all (u1,v1) and (u0,v0) in the domain of the surface f(u,v) we have : | u1 - u0 | < UTolerance and | v1 - v0 | < VTolerance we have |f (u1,v1) - f (u0,v0)| < Tolerance3D

        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UKnots:
        :type UKnots: TColStd_Array1OfReal &
        :param VKnots:
        :type VKnots: TColStd_Array1OfReal &
        :param UMults:
        :type UMults: TColStd_Array1OfInteger &
        :param VMults:
        :type VMults: TColStd_Array1OfInteger &
        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param URat:
        :type URat: bool
        :param VRat:
        :type VRat: bool
        :param UPer:
        :type UPer: bool
        :param VPer:
        :type VPer: bool
        :param Tolerance3D:
        :type Tolerance3D: float
        :param UTolerance:
        :type UTolerance: float &
        :param VTolerance:
        :type VTolerance: float &
        :rtype: void

        """
        return _BSplSLib.bsplslib_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def Interpolate(*args):
        """
        * Performs the interpolation of the data points given in  the Poles array in the form  [1,...,RL][1,...,RC][1...PolesDimension] . The ColLength CL and the Length of UParameters must be the same. The length of VFlatKnots is VDegree + CL + 1.  The RowLength RL and the Length of VParameters must be the same. The length of VFlatKnots is Degree + RL + 1. Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot

        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param UFlatKnots:
        :type UFlatKnots: TColStd_Array1OfReal &
        :param VFlatKnots:
        :type VFlatKnots: TColStd_Array1OfReal &
        :param UParameters:
        :type UParameters: TColStd_Array1OfReal &
        :param VParameters:
        :type VParameters: TColStd_Array1OfReal &
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param InversionProblem:
        :type InversionProblem: int &
        :rtype: void

        * Performs the interpolation of the data points given in the Poles array. The ColLength CL and the Length of UParameters must be the same. The length of VFlatKnots is VDegree + CL + 1.  The RowLength RL and the Length of VParameters must be the same. The length of VFlatKnots is Degree + RL + 1. Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot

        :param UDegree:
        :type UDegree: int
        :param VDegree:
        :type VDegree: int
        :param UFlatKnots:
        :type UFlatKnots: TColStd_Array1OfReal &
        :param VFlatKnots:
        :type VFlatKnots: TColStd_Array1OfReal &
        :param UParameters:
        :type UParameters: TColStd_Array1OfReal &
        :param VParameters:
        :type VParameters: TColStd_Array1OfReal &
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param InversionProblem:
        :type InversionProblem: int &
        :rtype: void

        """
        return _BSplSLib.bsplslib_Interpolate(*args)

    Interpolate = staticmethod(Interpolate)

    def FunctionMultiply(*args):
        """
        * this will multiply a given BSpline numerator N(u,v) and denominator D(u,v) defined by its U/VBSplineDegree and U/VBSplineKnots, and U/VMults. Its Poles and Weights are arrays which are coded as array2 of the form  [1..UNumPoles][1..VNumPoles] by a function a(u,v) which is assumed to satisfy the following : 1. a(u,v) * N(u,v) and a(u,v) * D(u,v) is a polynomial BSpline that can be expressed exactly as a BSpline of degree U/VNewDegree on the knots U/VFlatKnots 2. the range of a(u,v) is the same as the range of N(u,v) or D(u,v) ---Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method -- Status will return 0 if OK else it will return the  pivot index -- of the matrix that was inverted to compute the multiplied -- BSpline : the method used is interpolation at Schoenenberg -- points of a(u,v)* N(u,v) and a(u,v) * D(u,v) Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(u,v)*F(u,v) --

        :param Function:
        :type Function: BSplSLib_EvaluatorFunction &
        :param UBSplineDegree:
        :type UBSplineDegree: int
        :param VBSplineDegree:
        :type VBSplineDegree: int
        :param UBSplineKnots:
        :type UBSplineKnots: TColStd_Array1OfReal &
        :param VBSplineKnots:
        :type VBSplineKnots: TColStd_Array1OfReal &
        :param UMults:
        :type UMults: TColStd_Array1OfInteger &
        :param VMults:
        :type VMults: TColStd_Array1OfInteger &
        :param Poles:
        :type Poles: TColgp_Array2OfPnt
        :param Weights:
        :type Weights: TColStd_Array2OfReal &
        :param UFlatKnots:
        :type UFlatKnots: TColStd_Array1OfReal &
        :param VFlatKnots:
        :type VFlatKnots: TColStd_Array1OfReal &
        :param UNewDegree:
        :type UNewDegree: int
        :param VNewDegree:
        :type VNewDegree: int
        :param NewNumerator:
        :type NewNumerator: TColgp_Array2OfPnt
        :param NewDenominator:
        :type NewDenominator: TColStd_Array2OfReal &
        :param Status:
        :type Status: int &
        :rtype: void

        """
        return _BSplSLib.bsplslib_FunctionMultiply(*args)

    FunctionMultiply = staticmethod(FunctionMultiply)

    def __init__(self):
        _BSplSLib.bsplslib_swiginit(self, _BSplSLib.new_bsplslib())

    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


bsplslib._kill_pointed = new_instancemethod(_BSplSLib.bsplslib__kill_pointed, None, bsplslib)
bsplslib_swigregister = _BSplSLib.bsplslib_swigregister
bsplslib_swigregister(bsplslib)

def bsplslib_RationalDerivative(*args):
    """
    * this is a one dimensional function typedef void (*EvaluatorFunction) ( Standard_Integer // Derivative Request Standard_Real * // StartEnd[2][2]  // [0] = U  // [1] = V  // [0] = start  // [1] = end Standard_Real // UParameter Standard_Real // VParamerer Standard_Real & // Result Standard_Integer &) ;// Error Code serves to multiply a given vectorial BSpline by a function Computes the derivatives of a ratio of two-variables functions x(u,v) / w(u,v) at orders <N,M>, x(u,v) is a vector in dimension <3>.  <Ders> is an array containing the values of the input derivatives from 0 to Min(<N>,<UDeg>), 0 to Min(<M>,<VDeg>). For orders higher than <UDeg,VDeg> the input derivatives are assumed to be 0.  The <Ders> is a 2d array and the dimension of the lines is always (<VDeg>+1) * (<3>+1), even if <N> is smaller than <Udeg> (the derivatives higher than <N> are not used).  Content of <Ders> :  x(i,j)[k] means : the composant k of x derivated (i) times in u and (j) times in v.  ... First line ...  x[1],x[2],...,x[3],w x(0,1)[1],...,x(0,1)[3],w(1,0) ... x(0,VDeg)[1],...,x(0,VDeg)[3],w(0,VDeg)  ... Then second line ...  x(1,0)[1],...,x(1,0)[3],w(1,0) x(1,1)[1],...,x(1,1)[3],w(1,1) ... x(1,VDeg)[1],...,x(1,VDeg)[3],w(1,VDeg)  ...  ... Last line ...  x(UDeg,0)[1],...,x(UDeg,0)[3],w(UDeg,0) x(UDeg,1)[1],...,x(UDeg,1)[3],w(UDeg,1) ... x(Udeg,VDeg)[1],...,x(UDeg,VDeg)[3],w(Udeg,VDeg) If <All> is false, only the derivative at order <N,M> is computed. <RDers> is an array of length 3 which will contain the result :  x(1)/w , x(2)/w , ... derivated <N> <M> times  If <All> is true multiples derivatives are computed. All the derivatives (i,j) with 0 <= i+j <= Max(N,M) are computed. <RDers> is an array of length 3 * (<N>+1) * (<M>+1) which will contains :  x(1)/w , x(2)/w , ... x(1)/w , x(2)/w , ... derivated <0,1> times x(1)/w , x(2)/w , ... derivated <0,2> times ... x(1)/w , x(2)/w , ... derivated <0,N> times  x(1)/w , x(2)/w , ... derivated <1,0> times x(1)/w , x(2)/w , ... derivated <1,1> times ... x(1)/w , x(2)/w , ... derivated <1,N> times  x(1)/w , x(2)/w , ... derivated <N,0> times .... Warning: <RDers> must be dimensionned properly.

    :param UDeg:
    :type UDeg: int
    :param VDeg:
    :type VDeg: int
    :param N:
    :type N: int
    :param M:
    :type M: int
    :param Ders:
    :type Ders: float &
    :param RDers:
    :type RDers: float &
    :param All: default value is Standard_True
    :type All: bool
    :rtype: void

    """
    return _BSplSLib.bsplslib_RationalDerivative(*args)

def bsplslib_D0(*args):
    """
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param UIndex:
    :type UIndex: int
    :param VIndex:
    :type VIndex: int
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UKnots:
    :type UKnots: TColStd_Array1OfReal &
    :param VKnots:
    :type VKnots: TColStd_Array1OfReal &
    :param UMults:
    :type UMults: TColStd_Array1OfInteger &
    :param VMults:
    :type VMults: TColStd_Array1OfInteger &
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param URat:
    :type URat: bool
    :param VRat:
    :type VRat: bool
    :param UPer:
    :type UPer: bool
    :param VPer:
    :type VPer: bool
    :param P:
    :type P: gp_Pnt
    :rtype: void

    """
    return _BSplSLib.bsplslib_D0(*args)

def bsplslib_D1(*args):
    """
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param UIndex:
    :type UIndex: int
    :param VIndex:
    :type VIndex: int
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UKnots:
    :type UKnots: TColStd_Array1OfReal &
    :param VKnots:
    :type VKnots: TColStd_Array1OfReal &
    :param UMults:
    :type UMults: TColStd_Array1OfInteger &
    :param VMults:
    :type VMults: TColStd_Array1OfInteger &
    :param Degree:
    :type Degree: int
    :param VDegree:
    :type VDegree: int
    :param URat:
    :type URat: bool
    :param VRat:
    :type VRat: bool
    :param UPer:
    :type UPer: bool
    :param VPer:
    :type VPer: bool
    :param P:
    :type P: gp_Pnt
    :param Vu:
    :type Vu: gp_Vec
    :param Vv:
    :type Vv: gp_Vec
    :rtype: void

    """
    return _BSplSLib.bsplslib_D1(*args)

def bsplslib_D2(*args):
    """
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param UIndex:
    :type UIndex: int
    :param VIndex:
    :type VIndex: int
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UKnots:
    :type UKnots: TColStd_Array1OfReal &
    :param VKnots:
    :type VKnots: TColStd_Array1OfReal &
    :param UMults:
    :type UMults: TColStd_Array1OfInteger &
    :param VMults:
    :type VMults: TColStd_Array1OfInteger &
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param URat:
    :type URat: bool
    :param VRat:
    :type VRat: bool
    :param UPer:
    :type UPer: bool
    :param VPer:
    :type VPer: bool
    :param P:
    :type P: gp_Pnt
    :param Vu:
    :type Vu: gp_Vec
    :param Vv:
    :type Vv: gp_Vec
    :param Vuu:
    :type Vuu: gp_Vec
    :param Vvv:
    :type Vvv: gp_Vec
    :param Vuv:
    :type Vuv: gp_Vec
    :rtype: void

    """
    return _BSplSLib.bsplslib_D2(*args)

def bsplslib_D3(*args):
    """
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param UIndex:
    :type UIndex: int
    :param VIndex:
    :type VIndex: int
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UKnots:
    :type UKnots: TColStd_Array1OfReal &
    :param VKnots:
    :type VKnots: TColStd_Array1OfReal &
    :param UMults:
    :type UMults: TColStd_Array1OfInteger &
    :param VMults:
    :type VMults: TColStd_Array1OfInteger &
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param URat:
    :type URat: bool
    :param VRat:
    :type VRat: bool
    :param UPer:
    :type UPer: bool
    :param VPer:
    :type VPer: bool
    :param P:
    :type P: gp_Pnt
    :param Vu:
    :type Vu: gp_Vec
    :param Vv:
    :type Vv: gp_Vec
    :param Vuu:
    :type Vuu: gp_Vec
    :param Vvv:
    :type Vvv: gp_Vec
    :param Vuv:
    :type Vuv: gp_Vec
    :param Vuuu:
    :type Vuuu: gp_Vec
    :param Vvvv:
    :type Vvvv: gp_Vec
    :param Vuuv:
    :type Vuuv: gp_Vec
    :param Vuvv:
    :type Vuvv: gp_Vec
    :rtype: void

    """
    return _BSplSLib.bsplslib_D3(*args)

def bsplslib_DN(*args):
    """
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param Nu:
    :type Nu: int
    :param Nv:
    :type Nv: int
    :param UIndex:
    :type UIndex: int
    :param VIndex:
    :type VIndex: int
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UKnots:
    :type UKnots: TColStd_Array1OfReal &
    :param VKnots:
    :type VKnots: TColStd_Array1OfReal &
    :param UMults:
    :type UMults: TColStd_Array1OfInteger &
    :param VMults:
    :type VMults: TColStd_Array1OfInteger &
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param URat:
    :type URat: bool
    :param VRat:
    :type VRat: bool
    :param UPer:
    :type UPer: bool
    :param VPer:
    :type VPer: bool
    :param Vn:
    :type Vn: gp_Vec
    :rtype: void

    """
    return _BSplSLib.bsplslib_DN(*args)

def bsplslib_Iso(*args):
    """
    * Computes the poles and weights of an isoparametric curve at parameter <Param> (UIso if <IsU> is True, VIso else).

    :param Param:
    :type Param: float
    :param IsU:
    :type IsU: bool
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Knots:
    :type Knots: TColStd_Array1OfReal &
    :param Mults:
    :type Mults: TColStd_Array1OfInteger &
    :param Degree:
    :type Degree: int
    :param Periodic:
    :type Periodic: bool
    :param CPoles:
    :type CPoles: TColgp_Array1OfPnt
    :param CWeights:
    :type CWeights: TColStd_Array1OfReal &
    :rtype: void

    """
    return _BSplSLib.bsplslib_Iso(*args)

def bsplslib_HomogeneousD0(*args):
    """
    * Makes an homogeneous evaluation of Poles and Weights any and returns in P the Numerator value and in W the Denominator value if Weights are present otherwise returns 1.0e0

    :param U:
    :type U: float
    :param V:
    :type V: float
    :param UIndex:
    :type UIndex: int
    :param VIndex:
    :type VIndex: int
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UKnots:
    :type UKnots: TColStd_Array1OfReal &
    :param VKnots:
    :type VKnots: TColStd_Array1OfReal &
    :param UMults:
    :type UMults: TColStd_Array1OfInteger &
    :param VMults:
    :type VMults: TColStd_Array1OfInteger &
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param URat:
    :type URat: bool
    :param VRat:
    :type VRat: bool
    :param UPer:
    :type UPer: bool
    :param VPer:
    :type VPer: bool
    :param W:
    :type W: float &
    :param P:
    :type P: gp_Pnt
    :rtype: void

    """
    return _BSplSLib.bsplslib_HomogeneousD0(*args)

def bsplslib_HomogeneousD1(*args):
    """
    * Makes an homogeneous evaluation of Poles and Weights any and returns in P the Numerator value and in W the Denominator value if Weights are present otherwise returns 1.0e0

    :param U:
    :type U: float
    :param V:
    :type V: float
    :param UIndex:
    :type UIndex: int
    :param VIndex:
    :type VIndex: int
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UKnots:
    :type UKnots: TColStd_Array1OfReal &
    :param VKnots:
    :type VKnots: TColStd_Array1OfReal &
    :param UMults:
    :type UMults: TColStd_Array1OfInteger &
    :param VMults:
    :type VMults: TColStd_Array1OfInteger &
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param URat:
    :type URat: bool
    :param VRat:
    :type VRat: bool
    :param UPer:
    :type UPer: bool
    :param VPer:
    :type VPer: bool
    :param N:
    :type N: gp_Pnt
    :param Nu:
    :type Nu: gp_Vec
    :param Nv:
    :type Nv: gp_Vec
    :param D:
    :type D: float &
    :param Du:
    :type Du: float &
    :param Dv:
    :type Dv: float &
    :rtype: void

    """
    return _BSplSLib.bsplslib_HomogeneousD1(*args)

def bsplslib_Reverse(*args):
    """
    * Reverses the array of poles. Last is the Index of the new first Row( Col) of Poles. On a non periodic surface Last is  Poles.Upper(). On a periodic curve last is  (number of flat knots - degree - 1) or  (sum of multiplicities(but for the last) + degree - 1)

    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Last:
    :type Last: int
    :param UDirection:
    :type UDirection: bool
    :rtype: void

    * Reverses the array of weights.

    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Last:
    :type Last: int
    :param UDirection:
    :type UDirection: bool
    :rtype: void

    """
    return _BSplSLib.bsplslib_Reverse(*args)

def bsplslib_IsRational(*args):
    """
    * Returns False if all the weights of the array <Weights> in the area [I1,I2] * [J1,J2] are identic. Epsilon is used for comparing weights. If Epsilon is 0. the Epsilon of the first weight is used.

    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param I1:
    :type I1: int
    :param I2:
    :type I2: int
    :param J1:
    :type J1: int
    :param J2:
    :type J2: int
    :param Epsilon: default value is 0.0
    :type Epsilon: float
    :rtype: bool

    """
    return _BSplSLib.bsplslib_IsRational(*args)

def bsplslib_SetPoles(*args):
    """
    * Copy in FP the coordinates of the poles.

    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param FP:
    :type FP: TColStd_Array1OfReal &
    :param UDirection:
    :type UDirection: bool
    :rtype: void

    * Copy in FP the coordinates of the poles.

    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param FP:
    :type FP: TColStd_Array1OfReal &
    :param UDirection:
    :type UDirection: bool
    :rtype: void

    """
    return _BSplSLib.bsplslib_SetPoles(*args)

def bsplslib_GetPoles(*args):
    """
    * Get from FP the coordinates of the poles.

    :param FP:
    :type FP: TColStd_Array1OfReal &
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param UDirection:
    :type UDirection: bool
    :rtype: void

    * Get from FP the coordinates of the poles.

    :param FP:
    :type FP: TColStd_Array1OfReal &
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UDirection:
    :type UDirection: bool
    :rtype: void

    """
    return _BSplSLib.bsplslib_GetPoles(*args)

def bsplslib_MovePoint(*args):
    """
    * Find the new poles which allows an old point (with a given u,v as parameters) to reach a new position UIndex1,UIndex2 indicate the range of poles we can move for U (1, UNbPoles-1) or (2, UNbPoles) -> no constraint for one side in U (2, UNbPoles-1) -> the ends are enforced for U don't enter (1,NbPoles) and (1,VNbPoles) -> error: rigid move if problem in BSplineBasis calculation, no change for the curve and UFirstIndex, VLastIndex = 0 VFirstIndex, VLastIndex = 0

    :param U:
    :type U: float
    :param V:
    :type V: float
    :param Displ:
    :type Displ: gp_Vec
    :param UIndex1:
    :type UIndex1: int
    :param UIndex2:
    :type UIndex2: int
    :param VIndex1:
    :type VIndex1: int
    :param VIndex2:
    :type VIndex2: int
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param Rational:
    :type Rational: bool
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UFlatKnots:
    :type UFlatKnots: TColStd_Array1OfReal &
    :param VFlatKnots:
    :type VFlatKnots: TColStd_Array1OfReal &
    :param UFirstIndex:
    :type UFirstIndex: int &
    :param ULastIndex:
    :type ULastIndex: int &
    :param VFirstIndex:
    :type VFirstIndex: int &
    :param VLastIndex:
    :type VLastIndex: int &
    :param NewPoles:
    :type NewPoles: TColgp_Array2OfPnt
    :rtype: void

    """
    return _BSplSLib.bsplslib_MovePoint(*args)

def bsplslib_InsertKnots(*args):
    """
    :param UDirection:
    :type UDirection: bool
    :param Degree:
    :type Degree: int
    :param Periodic:
    :type Periodic: bool
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Knots:
    :type Knots: TColStd_Array1OfReal &
    :param Mults:
    :type Mults: TColStd_Array1OfInteger &
    :param AddKnots:
    :type AddKnots: TColStd_Array1OfReal &
    :param AddMults:
    :type AddMults: TColStd_Array1OfInteger &
    :param NewPoles:
    :type NewPoles: TColgp_Array2OfPnt
    :param NewWeights:
    :type NewWeights: TColStd_Array2OfReal &
    :param NewKnots:
    :type NewKnots: TColStd_Array1OfReal &
    :param NewMults:
    :type NewMults: TColStd_Array1OfInteger &
    :param Epsilon:
    :type Epsilon: float
    :param Add: default value is Standard_True
    :type Add: bool
    :rtype: void

    """
    return _BSplSLib.bsplslib_InsertKnots(*args)

def bsplslib_RemoveKnot(*args):
    """
    :param UDirection:
    :type UDirection: bool
    :param Index:
    :type Index: int
    :param Mult:
    :type Mult: int
    :param Degree:
    :type Degree: int
    :param Periodic:
    :type Periodic: bool
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Knots:
    :type Knots: TColStd_Array1OfReal &
    :param Mults:
    :type Mults: TColStd_Array1OfInteger &
    :param NewPoles:
    :type NewPoles: TColgp_Array2OfPnt
    :param NewWeights:
    :type NewWeights: TColStd_Array2OfReal &
    :param NewKnots:
    :type NewKnots: TColStd_Array1OfReal &
    :param NewMults:
    :type NewMults: TColStd_Array1OfInteger &
    :param Tolerance:
    :type Tolerance: float
    :rtype: bool

    """
    return _BSplSLib.bsplslib_RemoveKnot(*args)

def bsplslib_IncreaseDegree(*args):
    """
    :param UDirection:
    :type UDirection: bool
    :param Degree:
    :type Degree: int
    :param NewDegree:
    :type NewDegree: int
    :param Periodic:
    :type Periodic: bool
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Knots:
    :type Knots: TColStd_Array1OfReal &
    :param Mults:
    :type Mults: TColStd_Array1OfInteger &
    :param NewPoles:
    :type NewPoles: TColgp_Array2OfPnt
    :param NewWeights:
    :type NewWeights: TColStd_Array2OfReal &
    :param NewKnots:
    :type NewKnots: TColStd_Array1OfReal &
    :param NewMults:
    :type NewMults: TColStd_Array1OfInteger &
    :rtype: void

    """
    return _BSplSLib.bsplslib_IncreaseDegree(*args)

def bsplslib_Unperiodize(*args):
    """
    :param UDirection:
    :type UDirection: bool
    :param Degree:
    :type Degree: int
    :param Mults:
    :type Mults: TColStd_Array1OfInteger &
    :param Knots:
    :type Knots: TColStd_Array1OfReal &
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param NewMults:
    :type NewMults: TColStd_Array1OfInteger &
    :param NewKnots:
    :type NewKnots: TColStd_Array1OfReal &
    :param NewPoles:
    :type NewPoles: TColgp_Array2OfPnt
    :param NewWeights:
    :type NewWeights: TColStd_Array2OfReal &
    :rtype: void

    """
    return _BSplSLib.bsplslib_Unperiodize(*args)

def bsplslib_NoWeights(*args):
    """
    * Used as argument for a non rational curve.

    :rtype: TColStd_Array2OfReal

    """
    return _BSplSLib.bsplslib_NoWeights(*args)

def bsplslib_BuildCache(*args):
    """
    * Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles

    :param U:
    :type U: float
    :param V:
    :type V: float
    :param USpanDomain:
    :type USpanDomain: float
    :param VSpanDomain:
    :type VSpanDomain: float
    :param UPeriodicFlag:
    :type UPeriodicFlag: bool
    :param VPeriodicFlag:
    :type VPeriodicFlag: bool
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param UIndex:
    :type UIndex: int
    :param VIndex:
    :type VIndex: int
    :param UFlatKnots:
    :type UFlatKnots: TColStd_Array1OfReal &
    :param VFlatKnots:
    :type VFlatKnots: TColStd_Array1OfReal &
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param CachePoles:
    :type CachePoles: TColgp_Array2OfPnt
    :param CacheWeights:
    :type CacheWeights: TColStd_Array2OfReal &
    :rtype: void

    """
    return _BSplSLib.bsplslib_BuildCache(*args)

def bsplslib_CacheD0(*args):
    """
    * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects

    :param U:
    :type U: float
    :param V:
    :type V: float
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param UCacheParameter:
    :type UCacheParameter: float
    :param VCacheParameter:
    :type VCacheParameter: float
    :param USpanLenght:
    :type USpanLenght: float
    :param VSpanLength:
    :type VSpanLength: float
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Point:
    :type Point: gp_Pnt
    :rtype: void

    """
    return _BSplSLib.bsplslib_CacheD0(*args)

def bsplslib_CoefsD0(*args):
    """
    * Calls CacheD0 for Bezier Surfaces Arrays computed with the method PolesCoefficients. Warning: To be used for BezierSurfaces ONLY!!!

    :param U:
    :type U: float
    :param V:
    :type V: float
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Point:
    :type Point: gp_Pnt
    :rtype: void

    """
    return _BSplSLib.bsplslib_CoefsD0(*args)

def bsplslib_CacheD1(*args):
    """
    * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects

    :param U:
    :type U: float
    :param V:
    :type V: float
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param UCacheParameter:
    :type UCacheParameter: float
    :param VCacheParameter:
    :type VCacheParameter: float
    :param USpanLenght:
    :type USpanLenght: float
    :param VSpanLength:
    :type VSpanLength: float
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Point:
    :type Point: gp_Pnt
    :param VecU:
    :type VecU: gp_Vec
    :param VecV:
    :type VecV: gp_Vec
    :rtype: void

    """
    return _BSplSLib.bsplslib_CacheD1(*args)

def bsplslib_CoefsD1(*args):
    """
    * Calls CacheD0 for Bezier Surfaces Arrays computed with the method PolesCoefficients. Warning: To be used for BezierSurfaces ONLY!!!

    :param U:
    :type U: float
    :param V:
    :type V: float
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Point:
    :type Point: gp_Pnt
    :param VecU:
    :type VecU: gp_Vec
    :param VecV:
    :type VecV: gp_Vec
    :rtype: void

    """
    return _BSplSLib.bsplslib_CoefsD1(*args)

def bsplslib_CacheD2(*args):
    """
    * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects

    :param U:
    :type U: float
    :param V:
    :type V: float
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param UCacheParameter:
    :type UCacheParameter: float
    :param VCacheParameter:
    :type VCacheParameter: float
    :param USpanLenght:
    :type USpanLenght: float
    :param VSpanLength:
    :type VSpanLength: float
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Point:
    :type Point: gp_Pnt
    :param VecU:
    :type VecU: gp_Vec
    :param VecV:
    :type VecV: gp_Vec
    :param VecUU:
    :type VecUU: gp_Vec
    :param VecUV:
    :type VecUV: gp_Vec
    :param VecVV:
    :type VecVV: gp_Vec
    :rtype: void

    """
    return _BSplSLib.bsplslib_CacheD2(*args)

def bsplslib_CoefsD2(*args):
    """
    * Calls CacheD0 for Bezier Surfaces Arrays computed with the method PolesCoefficients. Warning: To be used for BezierSurfaces ONLY!!!

    :param U:
    :type U: float
    :param V:
    :type V: float
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param Point:
    :type Point: gp_Pnt
    :param VecU:
    :type VecU: gp_Vec
    :param VecV:
    :type VecV: gp_Vec
    :param VecUU:
    :type VecUU: gp_Vec
    :param VecUV:
    :type VecUV: gp_Vec
    :param VecVV:
    :type VecVV: gp_Vec
    :rtype: void

    """
    return _BSplSLib.bsplslib_CoefsD2(*args)

def bsplslib_PolesCoefficients(*args):
    """
    * Warning! To be used for BezierSurfaces ONLY!!!

    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param CachePoles:
    :type CachePoles: TColgp_Array2OfPnt
    :rtype: void

    * Encapsulation of BuildCache to perform the evaluation of the Taylor expansion for beziersurfaces at parameters 0.,0.; Warning: To be used for BezierSurfaces ONLY!!!

    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param CachePoles:
    :type CachePoles: TColgp_Array2OfPnt
    :param CacheWeights:
    :type CacheWeights: TColStd_Array2OfReal &
    :rtype: void

    """
    return _BSplSLib.bsplslib_PolesCoefficients(*args)

def bsplslib_Resolution(*args):
    """
    * Given a tolerance in 3D space returns two tolerances, one in U one in V such that for all (u1,v1) and (u0,v0) in the domain of the surface f(u,v) we have : | u1 - u0 | < UTolerance and | v1 - v0 | < VTolerance we have |f (u1,v1) - f (u0,v0)| < Tolerance3D

    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UKnots:
    :type UKnots: TColStd_Array1OfReal &
    :param VKnots:
    :type VKnots: TColStd_Array1OfReal &
    :param UMults:
    :type UMults: TColStd_Array1OfInteger &
    :param VMults:
    :type VMults: TColStd_Array1OfInteger &
    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param URat:
    :type URat: bool
    :param VRat:
    :type VRat: bool
    :param UPer:
    :type UPer: bool
    :param VPer:
    :type VPer: bool
    :param Tolerance3D:
    :type Tolerance3D: float
    :param UTolerance:
    :type UTolerance: float &
    :param VTolerance:
    :type VTolerance: float &
    :rtype: void

    """
    return _BSplSLib.bsplslib_Resolution(*args)

def bsplslib_Interpolate(*args):
    """
    * Performs the interpolation of the data points given in  the Poles array in the form  [1,...,RL][1,...,RC][1...PolesDimension] . The ColLength CL and the Length of UParameters must be the same. The length of VFlatKnots is VDegree + CL + 1.  The RowLength RL and the Length of VParameters must be the same. The length of VFlatKnots is Degree + RL + 1. Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot

    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param UFlatKnots:
    :type UFlatKnots: TColStd_Array1OfReal &
    :param VFlatKnots:
    :type VFlatKnots: TColStd_Array1OfReal &
    :param UParameters:
    :type UParameters: TColStd_Array1OfReal &
    :param VParameters:
    :type VParameters: TColStd_Array1OfReal &
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param InversionProblem:
    :type InversionProblem: int &
    :rtype: void

    * Performs the interpolation of the data points given in the Poles array. The ColLength CL and the Length of UParameters must be the same. The length of VFlatKnots is VDegree + CL + 1.  The RowLength RL and the Length of VParameters must be the same. The length of VFlatKnots is Degree + RL + 1. Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot

    :param UDegree:
    :type UDegree: int
    :param VDegree:
    :type VDegree: int
    :param UFlatKnots:
    :type UFlatKnots: TColStd_Array1OfReal &
    :param VFlatKnots:
    :type VFlatKnots: TColStd_Array1OfReal &
    :param UParameters:
    :type UParameters: TColStd_Array1OfReal &
    :param VParameters:
    :type VParameters: TColStd_Array1OfReal &
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param InversionProblem:
    :type InversionProblem: int &
    :rtype: void

    """
    return _BSplSLib.bsplslib_Interpolate(*args)

def bsplslib_FunctionMultiply(*args):
    """
    * this will multiply a given BSpline numerator N(u,v) and denominator D(u,v) defined by its U/VBSplineDegree and U/VBSplineKnots, and U/VMults. Its Poles and Weights are arrays which are coded as array2 of the form  [1..UNumPoles][1..VNumPoles] by a function a(u,v) which is assumed to satisfy the following : 1. a(u,v) * N(u,v) and a(u,v) * D(u,v) is a polynomial BSpline that can be expressed exactly as a BSpline of degree U/VNewDegree on the knots U/VFlatKnots 2. the range of a(u,v) is the same as the range of N(u,v) or D(u,v) ---Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method -- Status will return 0 if OK else it will return the  pivot index -- of the matrix that was inverted to compute the multiplied -- BSpline : the method used is interpolation at Schoenenberg -- points of a(u,v)* N(u,v) and a(u,v) * D(u,v) Status will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(u,v)*F(u,v) --

    :param Function:
    :type Function: BSplSLib_EvaluatorFunction &
    :param UBSplineDegree:
    :type UBSplineDegree: int
    :param VBSplineDegree:
    :type VBSplineDegree: int
    :param UBSplineKnots:
    :type UBSplineKnots: TColStd_Array1OfReal &
    :param VBSplineKnots:
    :type VBSplineKnots: TColStd_Array1OfReal &
    :param UMults:
    :type UMults: TColStd_Array1OfInteger &
    :param VMults:
    :type VMults: TColStd_Array1OfInteger &
    :param Poles:
    :type Poles: TColgp_Array2OfPnt
    :param Weights:
    :type Weights: TColStd_Array2OfReal &
    :param UFlatKnots:
    :type UFlatKnots: TColStd_Array1OfReal &
    :param VFlatKnots:
    :type VFlatKnots: TColStd_Array1OfReal &
    :param UNewDegree:
    :type UNewDegree: int
    :param VNewDegree:
    :type VNewDegree: int
    :param NewNumerator:
    :type NewNumerator: TColgp_Array2OfPnt
    :param NewDenominator:
    :type NewDenominator: TColStd_Array2OfReal &
    :param Status:
    :type Status: int &
    :rtype: void

    """
    return _BSplSLib.bsplslib_FunctionMultiply(*args)



