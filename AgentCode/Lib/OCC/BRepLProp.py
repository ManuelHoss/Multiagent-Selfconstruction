# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _BRepLProp.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepLProp', [dirname(__file__)])
        except ImportError:
            import _BRepLProp
            return _BRepLProp
        if fp is not None:
            try:
                _mod = imp.load_module('_BRepLProp', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _BRepLProp = swig_import_helper()
    del swig_import_helper
else:
    import _BRepLProp
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepLProp.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_BRepLProp.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BRepLProp.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BRepLProp.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BRepLProp.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BRepLProp.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BRepLProp.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BRepLProp.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BRepLProp.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BRepLProp.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BRepLProp.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BRepLProp.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BRepLProp.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BRepLProp.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BRepLProp.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BRepLProp.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BRepLProp.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _BRepLProp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.BRepAdaptor
import OCC.Standard
import OCC.Adaptor3d
import OCC.GeomAbs
import OCC.TColStd
import OCC.TCollection
import OCC.MMgt
import OCC.gp
import OCC.Geom
import OCC.TColgp
import OCC.Adaptor2d
import OCC.Geom2d
import OCC.TopAbs
import OCC.math
import OCC.TopoDS
import OCC.TopLoc
import OCC.GeomAdaptor
import OCC.Geom2dAdaptor
class breplprop(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Continuity(*args):
        """
        * Computes the regularity at the junction between C1 and C2. The point u1 on C1 and the point u2 on C2 must be confused. tl and ta are the linear and angular tolerance used two compare the derivative.

        :param C1:
        :type C1: BRepAdaptor_Curve &
        :param C2:
        :type C2: BRepAdaptor_Curve &
        :param u1:
        :type u1: float
        :param u2:
        :type u2: float
        :param tl:
        :type tl: float
        :param ta:
        :type ta: float
        :rtype: GeomAbs_Shape

        * The same as preciding but using the standard tolerances from package Precision.

        :param C1:
        :type C1: BRepAdaptor_Curve &
        :param C2:
        :type C2: BRepAdaptor_Curve &
        :param u1:
        :type u1: float
        :param u2:
        :type u2: float
        :rtype: GeomAbs_Shape

        """
        return _BRepLProp.breplprop_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def __init__(self):
        _BRepLProp.breplprop_swiginit(self, _BRepLProp.new_breplprop())

    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


breplprop._kill_pointed = new_instancemethod(_BRepLProp.breplprop__kill_pointed, None, breplprop)
breplprop_swigregister = _BRepLProp.breplprop_swigregister
breplprop_swigregister(breplprop)

def breplprop_Continuity(*args):
    """
    * Computes the regularity at the junction between C1 and C2. The point u1 on C1 and the point u2 on C2 must be confused. tl and ta are the linear and angular tolerance used two compare the derivative.

    :param C1:
    :type C1: BRepAdaptor_Curve &
    :param C2:
    :type C2: BRepAdaptor_Curve &
    :param u1:
    :type u1: float
    :param u2:
    :type u2: float
    :param tl:
    :type tl: float
    :param ta:
    :type ta: float
    :rtype: GeomAbs_Shape

    * The same as preciding but using the standard tolerances from package Precision.

    :param C1:
    :type C1: BRepAdaptor_Curve &
    :param C2:
    :type C2: BRepAdaptor_Curve &
    :param u1:
    :type u1: float
    :param u2:
    :type u2: float
    :rtype: GeomAbs_Shape

    """
    return _BRepLProp.breplprop_Continuity(*args)

class BRepLProp_CLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param C:
        :type C: BRepAdaptor_Curve &
        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        :param C:
        :type C: BRepAdaptor_Curve &
        :param U:
        :type U: float
        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        """
        _BRepLProp.BRepLProp_CLProps_swiginit(self, _BRepLProp.new_BRepLProp_CLProps(*args))

    def SetParameter(self, *args):
        """
        :param U:
        :type U: float
        :rtype: None

        """
        return _BRepLProp.BRepLProp_CLProps_SetParameter(self, *args)


    def SetCurve(self, *args):
        """
        :param C:
        :type C: BRepAdaptor_Curve &
        :rtype: None

        """
        return _BRepLProp.BRepLProp_CLProps_SetCurve(self, *args)


    def Value(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _BRepLProp.BRepLProp_CLProps_Value(self, *args)


    def D1(self, *args):
        """
        :rtype: gp_Vec

        """
        return _BRepLProp.BRepLProp_CLProps_D1(self, *args)


    def D2(self, *args):
        """
        :rtype: gp_Vec

        """
        return _BRepLProp.BRepLProp_CLProps_D2(self, *args)


    def D3(self, *args):
        """
        :rtype: gp_Vec

        """
        return _BRepLProp.BRepLProp_CLProps_D3(self, *args)


    def IsTangentDefined(self, *args):
        """
        :rtype: bool

        """
        return _BRepLProp.BRepLProp_CLProps_IsTangentDefined(self, *args)


    def Tangent(self, *args):
        """
        :param D:
        :type D: gp_Dir
        :rtype: None

        """
        return _BRepLProp.BRepLProp_CLProps_Tangent(self, *args)


    def Curvature(self, *args):
        """
        :rtype: float

        """
        return _BRepLProp.BRepLProp_CLProps_Curvature(self, *args)


    def Normal(self, *args):
        """
        :param N:
        :type N: gp_Dir
        :rtype: None

        """
        return _BRepLProp.BRepLProp_CLProps_Normal(self, *args)


    def CentreOfCurvature(self, *args):
        """
        :param P:
        :type P: gp_Pnt
        :rtype: None

        """
        return _BRepLProp.BRepLProp_CLProps_CentreOfCurvature(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


BRepLProp_CLProps.SetParameter = new_instancemethod(_BRepLProp.BRepLProp_CLProps_SetParameter, None, BRepLProp_CLProps)
BRepLProp_CLProps.SetCurve = new_instancemethod(_BRepLProp.BRepLProp_CLProps_SetCurve, None, BRepLProp_CLProps)
BRepLProp_CLProps.Value = new_instancemethod(_BRepLProp.BRepLProp_CLProps_Value, None, BRepLProp_CLProps)
BRepLProp_CLProps.D1 = new_instancemethod(_BRepLProp.BRepLProp_CLProps_D1, None, BRepLProp_CLProps)
BRepLProp_CLProps.D2 = new_instancemethod(_BRepLProp.BRepLProp_CLProps_D2, None, BRepLProp_CLProps)
BRepLProp_CLProps.D3 = new_instancemethod(_BRepLProp.BRepLProp_CLProps_D3, None, BRepLProp_CLProps)
BRepLProp_CLProps.IsTangentDefined = new_instancemethod(_BRepLProp.BRepLProp_CLProps_IsTangentDefined, None, BRepLProp_CLProps)
BRepLProp_CLProps.Tangent = new_instancemethod(_BRepLProp.BRepLProp_CLProps_Tangent, None, BRepLProp_CLProps)
BRepLProp_CLProps.Curvature = new_instancemethod(_BRepLProp.BRepLProp_CLProps_Curvature, None, BRepLProp_CLProps)
BRepLProp_CLProps.Normal = new_instancemethod(_BRepLProp.BRepLProp_CLProps_Normal, None, BRepLProp_CLProps)
BRepLProp_CLProps.CentreOfCurvature = new_instancemethod(_BRepLProp.BRepLProp_CLProps_CentreOfCurvature, None, BRepLProp_CLProps)
BRepLProp_CLProps._kill_pointed = new_instancemethod(_BRepLProp.BRepLProp_CLProps__kill_pointed, None, BRepLProp_CLProps)
BRepLProp_CLProps_swigregister = _BRepLProp.BRepLProp_CLProps_swigregister
BRepLProp_CLProps_swigregister(BRepLProp_CLProps)

class BRepLProp_CurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value(*args):
        """
        * Computes the point <P> of parameter <U> on the curve <C>.

        :param C:
        :type C: BRepAdaptor_Curve &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt
        :rtype: void

        """
        return _BRepLProp.BRepLProp_CurveTool_Value(*args)

    Value = staticmethod(Value)

    def D1(*args):
        """
        * Computes the point <P> and first derivative <V1> of parameter <U> on the curve <C>.

        :param C:
        :type C: BRepAdaptor_Curve &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt
        :param V1:
        :type V1: gp_Vec
        :rtype: void

        """
        return _BRepLProp.BRepLProp_CurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        * Computes the point <P>, the first derivative <V1> and second derivative <V2> of parameter <U> on the curve <C>.

        :param C:
        :type C: BRepAdaptor_Curve &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt
        :param V1:
        :type V1: gp_Vec
        :param V2:
        :type V2: gp_Vec
        :rtype: void

        """
        return _BRepLProp.BRepLProp_CurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        * Computes the point <P>, the first derivative <V1>, the second derivative <V2> and third derivative <V3> of parameter <U> on the curve <C>.

        :param C:
        :type C: BRepAdaptor_Curve &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt
        :param V1:
        :type V1: gp_Vec
        :param V2:
        :type V2: gp_Vec
        :param V3:
        :type V3: gp_Vec
        :rtype: void

        """
        return _BRepLProp.BRepLProp_CurveTool_D3(*args)

    D3 = staticmethod(D3)

    def Continuity(*args):
        """
        * returns the order of continuity of the curve <C>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable. returns 3 : first, second and third are computable.

        :param C:
        :type C: BRepAdaptor_Curve &
        :rtype: int

        """
        return _BRepLProp.BRepLProp_CurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def FirstParameter(*args):
        """
        * returns the first parameter bound of the curve.

        :param C:
        :type C: BRepAdaptor_Curve &
        :rtype: float

        """
        return _BRepLProp.BRepLProp_CurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        * returns the last parameter bound of the curve. FirstParameter must be less than LastParamenter.

        :param C:
        :type C: BRepAdaptor_Curve &
        :rtype: float

        """
        return _BRepLProp.BRepLProp_CurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def __init__(self):
        _BRepLProp.BRepLProp_CurveTool_swiginit(self, _BRepLProp.new_BRepLProp_CurveTool())

    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


BRepLProp_CurveTool._kill_pointed = new_instancemethod(_BRepLProp.BRepLProp_CurveTool__kill_pointed, None, BRepLProp_CurveTool)
BRepLProp_CurveTool_swigregister = _BRepLProp.BRepLProp_CurveTool_swigregister
BRepLProp_CurveTool_swigregister(BRepLProp_CurveTool)

def BRepLProp_CurveTool_Value(*args):
    """
    * Computes the point <P> of parameter <U> on the curve <C>.

    :param C:
    :type C: BRepAdaptor_Curve &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt
    :rtype: void

    """
    return _BRepLProp.BRepLProp_CurveTool_Value(*args)

def BRepLProp_CurveTool_D1(*args):
    """
    * Computes the point <P> and first derivative <V1> of parameter <U> on the curve <C>.

    :param C:
    :type C: BRepAdaptor_Curve &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt
    :param V1:
    :type V1: gp_Vec
    :rtype: void

    """
    return _BRepLProp.BRepLProp_CurveTool_D1(*args)

def BRepLProp_CurveTool_D2(*args):
    """
    * Computes the point <P>, the first derivative <V1> and second derivative <V2> of parameter <U> on the curve <C>.

    :param C:
    :type C: BRepAdaptor_Curve &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt
    :param V1:
    :type V1: gp_Vec
    :param V2:
    :type V2: gp_Vec
    :rtype: void

    """
    return _BRepLProp.BRepLProp_CurveTool_D2(*args)

def BRepLProp_CurveTool_D3(*args):
    """
    * Computes the point <P>, the first derivative <V1>, the second derivative <V2> and third derivative <V3> of parameter <U> on the curve <C>.

    :param C:
    :type C: BRepAdaptor_Curve &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt
    :param V1:
    :type V1: gp_Vec
    :param V2:
    :type V2: gp_Vec
    :param V3:
    :type V3: gp_Vec
    :rtype: void

    """
    return _BRepLProp.BRepLProp_CurveTool_D3(*args)

def BRepLProp_CurveTool_Continuity(*args):
    """
    * returns the order of continuity of the curve <C>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable. returns 3 : first, second and third are computable.

    :param C:
    :type C: BRepAdaptor_Curve &
    :rtype: int

    """
    return _BRepLProp.BRepLProp_CurveTool_Continuity(*args)

def BRepLProp_CurveTool_FirstParameter(*args):
    """
    * returns the first parameter bound of the curve.

    :param C:
    :type C: BRepAdaptor_Curve &
    :rtype: float

    """
    return _BRepLProp.BRepLProp_CurveTool_FirstParameter(*args)

def BRepLProp_CurveTool_LastParameter(*args):
    """
    * returns the last parameter bound of the curve. FirstParameter must be less than LastParamenter.

    :param C:
    :type C: BRepAdaptor_Curve &
    :rtype: float

    """
    return _BRepLProp.BRepLProp_CurveTool_LastParameter(*args)

class BRepLProp_SLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param S:
        :type S: BRepAdaptor_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        :param S:
        :type S: BRepAdaptor_Surface &
        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        """
        _BRepLProp.BRepLProp_SLProps_swiginit(self, _BRepLProp.new_BRepLProp_SLProps(*args))

    def SetSurface(self, *args):
        """
        :param S:
        :type S: BRepAdaptor_Surface &
        :rtype: None

        """
        return _BRepLProp.BRepLProp_SLProps_SetSurface(self, *args)


    def SetParameters(self, *args):
        """
        :param U:
        :type U: float
        :param V:
        :type V: float
        :rtype: None

        """
        return _BRepLProp.BRepLProp_SLProps_SetParameters(self, *args)


    def Value(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _BRepLProp.BRepLProp_SLProps_Value(self, *args)


    def D1U(self, *args):
        """
        :rtype: gp_Vec

        """
        return _BRepLProp.BRepLProp_SLProps_D1U(self, *args)


    def D1V(self, *args):
        """
        :rtype: gp_Vec

        """
        return _BRepLProp.BRepLProp_SLProps_D1V(self, *args)


    def D2U(self, *args):
        """
        :rtype: gp_Vec

        """
        return _BRepLProp.BRepLProp_SLProps_D2U(self, *args)


    def D2V(self, *args):
        """
        :rtype: gp_Vec

        """
        return _BRepLProp.BRepLProp_SLProps_D2V(self, *args)


    def DUV(self, *args):
        """
        :rtype: gp_Vec

        """
        return _BRepLProp.BRepLProp_SLProps_DUV(self, *args)


    def IsTangentUDefined(self, *args):
        """
        :rtype: bool

        """
        return _BRepLProp.BRepLProp_SLProps_IsTangentUDefined(self, *args)


    def TangentU(self, *args):
        """
        :param D:
        :type D: gp_Dir
        :rtype: None

        """
        return _BRepLProp.BRepLProp_SLProps_TangentU(self, *args)


    def IsTangentVDefined(self, *args):
        """
        :rtype: bool

        """
        return _BRepLProp.BRepLProp_SLProps_IsTangentVDefined(self, *args)


    def TangentV(self, *args):
        """
        :param D:
        :type D: gp_Dir
        :rtype: None

        """
        return _BRepLProp.BRepLProp_SLProps_TangentV(self, *args)


    def IsNormalDefined(self, *args):
        """
        :rtype: bool

        """
        return _BRepLProp.BRepLProp_SLProps_IsNormalDefined(self, *args)


    def Normal(self, *args):
        """
        :rtype: gp_Dir

        """
        return _BRepLProp.BRepLProp_SLProps_Normal(self, *args)


    def IsCurvatureDefined(self, *args):
        """
        :rtype: bool

        """
        return _BRepLProp.BRepLProp_SLProps_IsCurvatureDefined(self, *args)


    def IsUmbilic(self, *args):
        """
        :rtype: bool

        """
        return _BRepLProp.BRepLProp_SLProps_IsUmbilic(self, *args)


    def MaxCurvature(self, *args):
        """
        :rtype: float

        """
        return _BRepLProp.BRepLProp_SLProps_MaxCurvature(self, *args)


    def MinCurvature(self, *args):
        """
        :rtype: float

        """
        return _BRepLProp.BRepLProp_SLProps_MinCurvature(self, *args)


    def CurvatureDirections(self, *args):
        """
        :param MaxD:
        :type MaxD: gp_Dir
        :param MinD:
        :type MinD: gp_Dir
        :rtype: None

        """
        return _BRepLProp.BRepLProp_SLProps_CurvatureDirections(self, *args)


    def MeanCurvature(self, *args):
        """
        :rtype: float

        """
        return _BRepLProp.BRepLProp_SLProps_MeanCurvature(self, *args)


    def GaussianCurvature(self, *args):
        """
        :rtype: float

        """
        return _BRepLProp.BRepLProp_SLProps_GaussianCurvature(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


BRepLProp_SLProps.SetSurface = new_instancemethod(_BRepLProp.BRepLProp_SLProps_SetSurface, None, BRepLProp_SLProps)
BRepLProp_SLProps.SetParameters = new_instancemethod(_BRepLProp.BRepLProp_SLProps_SetParameters, None, BRepLProp_SLProps)
BRepLProp_SLProps.Value = new_instancemethod(_BRepLProp.BRepLProp_SLProps_Value, None, BRepLProp_SLProps)
BRepLProp_SLProps.D1U = new_instancemethod(_BRepLProp.BRepLProp_SLProps_D1U, None, BRepLProp_SLProps)
BRepLProp_SLProps.D1V = new_instancemethod(_BRepLProp.BRepLProp_SLProps_D1V, None, BRepLProp_SLProps)
BRepLProp_SLProps.D2U = new_instancemethod(_BRepLProp.BRepLProp_SLProps_D2U, None, BRepLProp_SLProps)
BRepLProp_SLProps.D2V = new_instancemethod(_BRepLProp.BRepLProp_SLProps_D2V, None, BRepLProp_SLProps)
BRepLProp_SLProps.DUV = new_instancemethod(_BRepLProp.BRepLProp_SLProps_DUV, None, BRepLProp_SLProps)
BRepLProp_SLProps.IsTangentUDefined = new_instancemethod(_BRepLProp.BRepLProp_SLProps_IsTangentUDefined, None, BRepLProp_SLProps)
BRepLProp_SLProps.TangentU = new_instancemethod(_BRepLProp.BRepLProp_SLProps_TangentU, None, BRepLProp_SLProps)
BRepLProp_SLProps.IsTangentVDefined = new_instancemethod(_BRepLProp.BRepLProp_SLProps_IsTangentVDefined, None, BRepLProp_SLProps)
BRepLProp_SLProps.TangentV = new_instancemethod(_BRepLProp.BRepLProp_SLProps_TangentV, None, BRepLProp_SLProps)
BRepLProp_SLProps.IsNormalDefined = new_instancemethod(_BRepLProp.BRepLProp_SLProps_IsNormalDefined, None, BRepLProp_SLProps)
BRepLProp_SLProps.Normal = new_instancemethod(_BRepLProp.BRepLProp_SLProps_Normal, None, BRepLProp_SLProps)
BRepLProp_SLProps.IsCurvatureDefined = new_instancemethod(_BRepLProp.BRepLProp_SLProps_IsCurvatureDefined, None, BRepLProp_SLProps)
BRepLProp_SLProps.IsUmbilic = new_instancemethod(_BRepLProp.BRepLProp_SLProps_IsUmbilic, None, BRepLProp_SLProps)
BRepLProp_SLProps.MaxCurvature = new_instancemethod(_BRepLProp.BRepLProp_SLProps_MaxCurvature, None, BRepLProp_SLProps)
BRepLProp_SLProps.MinCurvature = new_instancemethod(_BRepLProp.BRepLProp_SLProps_MinCurvature, None, BRepLProp_SLProps)
BRepLProp_SLProps.CurvatureDirections = new_instancemethod(_BRepLProp.BRepLProp_SLProps_CurvatureDirections, None, BRepLProp_SLProps)
BRepLProp_SLProps.MeanCurvature = new_instancemethod(_BRepLProp.BRepLProp_SLProps_MeanCurvature, None, BRepLProp_SLProps)
BRepLProp_SLProps.GaussianCurvature = new_instancemethod(_BRepLProp.BRepLProp_SLProps_GaussianCurvature, None, BRepLProp_SLProps)
BRepLProp_SLProps._kill_pointed = new_instancemethod(_BRepLProp.BRepLProp_SLProps__kill_pointed, None, BRepLProp_SLProps)
BRepLProp_SLProps_swigregister = _BRepLProp.BRepLProp_SLProps_swigregister
BRepLProp_SLProps_swigregister(BRepLProp_SLProps)

class BRepLProp_SurfaceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value(*args):
        """
        * Computes the point <P> of parameter <U> and <V> on the Surface <S>.

        :param S:
        :type S: BRepAdaptor_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param P:
        :type P: gp_Pnt
        :rtype: void

        """
        return _BRepLProp.BRepLProp_SurfaceTool_Value(*args)

    Value = staticmethod(Value)

    def D1(*args):
        """
        * Computes the point <P> and first derivative <D1*> of parameter <U> and <V> on the Surface <S>.

        :param S:
        :type S: BRepAdaptor_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param P:
        :type P: gp_Pnt
        :param D1U:
        :type D1U: gp_Vec
        :param D1V:
        :type D1V: gp_Vec
        :rtype: void

        """
        return _BRepLProp.BRepLProp_SurfaceTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        * Computes the point <P>, the first derivative <D1*> and second derivative <D2*> of parameter <U> and <V> on the Surface <S>.

        :param S:
        :type S: BRepAdaptor_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param P:
        :type P: gp_Pnt
        :param D1U:
        :type D1U: gp_Vec
        :param D1V:
        :type D1V: gp_Vec
        :param D2U:
        :type D2U: gp_Vec
        :param D2V:
        :type D2V: gp_Vec
        :param DUV:
        :type DUV: gp_Vec
        :rtype: void

        """
        return _BRepLProp.BRepLProp_SurfaceTool_D2(*args)

    D2 = staticmethod(D2)

    def DN(*args):
        """
        :param S:
        :type S: BRepAdaptor_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param IU:
        :type IU: int
        :param IV:
        :type IV: int
        :rtype: gp_Vec

        """
        return _BRepLProp.BRepLProp_SurfaceTool_DN(*args)

    DN = staticmethod(DN)

    def Continuity(*args):
        """
        * returns the order of continuity of the Surface <S>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable.

        :param S:
        :type S: BRepAdaptor_Surface &
        :rtype: int

        """
        return _BRepLProp.BRepLProp_SurfaceTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def Bounds(*args):
        """
        * returns the bounds of the Surface.

        :param S:
        :type S: BRepAdaptor_Surface &
        :param U1:
        :type U1: float &
        :param V1:
        :type V1: float &
        :param U2:
        :type U2: float &
        :param V2:
        :type V2: float &
        :rtype: void

        """
        return _BRepLProp.BRepLProp_SurfaceTool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def __init__(self):
        _BRepLProp.BRepLProp_SurfaceTool_swiginit(self, _BRepLProp.new_BRepLProp_SurfaceTool())

    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


BRepLProp_SurfaceTool._kill_pointed = new_instancemethod(_BRepLProp.BRepLProp_SurfaceTool__kill_pointed, None, BRepLProp_SurfaceTool)
BRepLProp_SurfaceTool_swigregister = _BRepLProp.BRepLProp_SurfaceTool_swigregister
BRepLProp_SurfaceTool_swigregister(BRepLProp_SurfaceTool)

def BRepLProp_SurfaceTool_Value(*args):
    """
    * Computes the point <P> of parameter <U> and <V> on the Surface <S>.

    :param S:
    :type S: BRepAdaptor_Surface &
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param P:
    :type P: gp_Pnt
    :rtype: void

    """
    return _BRepLProp.BRepLProp_SurfaceTool_Value(*args)

def BRepLProp_SurfaceTool_D1(*args):
    """
    * Computes the point <P> and first derivative <D1*> of parameter <U> and <V> on the Surface <S>.

    :param S:
    :type S: BRepAdaptor_Surface &
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param P:
    :type P: gp_Pnt
    :param D1U:
    :type D1U: gp_Vec
    :param D1V:
    :type D1V: gp_Vec
    :rtype: void

    """
    return _BRepLProp.BRepLProp_SurfaceTool_D1(*args)

def BRepLProp_SurfaceTool_D2(*args):
    """
    * Computes the point <P>, the first derivative <D1*> and second derivative <D2*> of parameter <U> and <V> on the Surface <S>.

    :param S:
    :type S: BRepAdaptor_Surface &
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param P:
    :type P: gp_Pnt
    :param D1U:
    :type D1U: gp_Vec
    :param D1V:
    :type D1V: gp_Vec
    :param D2U:
    :type D2U: gp_Vec
    :param D2V:
    :type D2V: gp_Vec
    :param DUV:
    :type DUV: gp_Vec
    :rtype: void

    """
    return _BRepLProp.BRepLProp_SurfaceTool_D2(*args)

def BRepLProp_SurfaceTool_DN(*args):
    """
    :param S:
    :type S: BRepAdaptor_Surface &
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param IU:
    :type IU: int
    :param IV:
    :type IV: int
    :rtype: gp_Vec

    """
    return _BRepLProp.BRepLProp_SurfaceTool_DN(*args)

def BRepLProp_SurfaceTool_Continuity(*args):
    """
    * returns the order of continuity of the Surface <S>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable.

    :param S:
    :type S: BRepAdaptor_Surface &
    :rtype: int

    """
    return _BRepLProp.BRepLProp_SurfaceTool_Continuity(*args)

def BRepLProp_SurfaceTool_Bounds(*args):
    """
    * returns the bounds of the Surface.

    :param S:
    :type S: BRepAdaptor_Surface &
    :param U1:
    :type U1: float &
    :param V1:
    :type V1: float &
    :param U2:
    :type U2: float &
    :param V2:
    :type V2: float &
    :rtype: void

    """
    return _BRepLProp.BRepLProp_SurfaceTool_Bounds(*args)



