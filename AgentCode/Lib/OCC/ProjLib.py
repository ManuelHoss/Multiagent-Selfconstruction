# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _ProjLib.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ProjLib', [dirname(__file__)])
        except ImportError:
            import _ProjLib
            return _ProjLib
        if fp is not None:
            try:
                _mod = imp.load_module('_ProjLib', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ProjLib = swig_import_helper()
    del swig_import_helper
else:
    import _ProjLib
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ProjLib.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_ProjLib.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_ProjLib.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_ProjLib.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_ProjLib.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_ProjLib.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_ProjLib.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_ProjLib.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_ProjLib.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_ProjLib.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_ProjLib.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_ProjLib.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_ProjLib.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_ProjLib.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_ProjLib.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_ProjLib.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_ProjLib.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _ProjLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.gp
import OCC.Standard
import OCC.Adaptor2d
import OCC.GeomAbs
import OCC.TColStd
import OCC.TCollection
import OCC.MMgt
import OCC.Geom2d
import OCC.TColgp
import OCC.Adaptor3d
import OCC.Geom
import OCC.TopAbs
import OCC.math
class projlib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Project(*args):
        """
        * Projection on a torus.

        :param Pl:
        :type Pl: gp_Pln
        :param P:
        :type P: gp_Pnt
        :rtype: gp_Pnt2d

        :param Pl:
        :type Pl: gp_Pln
        :param L:
        :type L: gp_Lin
        :rtype: gp_Lin2d

        :param Pl:
        :type Pl: gp_Pln
        :param C:
        :type C: gp_Circ
        :rtype: gp_Circ2d

        :param Pl:
        :type Pl: gp_Pln
        :param E:
        :type E: gp_Elips
        :rtype: gp_Elips2d

        :param Pl:
        :type Pl: gp_Pln
        :param P:
        :type P: gp_Parab
        :rtype: gp_Parab2d

        :param Pl:
        :type Pl: gp_Pln
        :param H:
        :type H: gp_Hypr
        :rtype: gp_Hypr2d

        :param Cy:
        :type Cy: gp_Cylinder
        :param P:
        :type P: gp_Pnt
        :rtype: gp_Pnt2d

        :param Cy:
        :type Cy: gp_Cylinder
        :param L:
        :type L: gp_Lin
        :rtype: gp_Lin2d

        :param Cy:
        :type Cy: gp_Cylinder
        :param Ci:
        :type Ci: gp_Circ
        :rtype: gp_Lin2d

        :param Co:
        :type Co: gp_Cone
        :param P:
        :type P: gp_Pnt
        :rtype: gp_Pnt2d

        :param Co:
        :type Co: gp_Cone
        :param L:
        :type L: gp_Lin
        :rtype: gp_Lin2d

        :param Co:
        :type Co: gp_Cone
        :param Ci:
        :type Ci: gp_Circ
        :rtype: gp_Lin2d

        :param Sp:
        :type Sp: gp_Sphere
        :param P:
        :type P: gp_Pnt
        :rtype: gp_Pnt2d

        :param Sp:
        :type Sp: gp_Sphere
        :param Ci:
        :type Ci: gp_Circ
        :rtype: gp_Lin2d

        :param To:
        :type To: gp_Torus
        :param P:
        :type P: gp_Pnt
        :rtype: gp_Pnt2d

        :param To:
        :type To: gp_Torus
        :param Ci:
        :type Ci: gp_Circ
        :rtype: gp_Lin2d

        """
        return _ProjLib.projlib_Project(*args)

    Project = staticmethod(Project)

    def __init__(self):
        _ProjLib.projlib_swiginit(self, _ProjLib.new_projlib())

    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


projlib._kill_pointed = new_instancemethod(_ProjLib.projlib__kill_pointed, None, projlib)
projlib_swigregister = _ProjLib.projlib_swigregister
projlib_swigregister(projlib)

def projlib_Project(*args):
    """
    * Projection on a torus.

    :param Pl:
    :type Pl: gp_Pln
    :param P:
    :type P: gp_Pnt
    :rtype: gp_Pnt2d

    :param Pl:
    :type Pl: gp_Pln
    :param L:
    :type L: gp_Lin
    :rtype: gp_Lin2d

    :param Pl:
    :type Pl: gp_Pln
    :param C:
    :type C: gp_Circ
    :rtype: gp_Circ2d

    :param Pl:
    :type Pl: gp_Pln
    :param E:
    :type E: gp_Elips
    :rtype: gp_Elips2d

    :param Pl:
    :type Pl: gp_Pln
    :param P:
    :type P: gp_Parab
    :rtype: gp_Parab2d

    :param Pl:
    :type Pl: gp_Pln
    :param H:
    :type H: gp_Hypr
    :rtype: gp_Hypr2d

    :param Cy:
    :type Cy: gp_Cylinder
    :param P:
    :type P: gp_Pnt
    :rtype: gp_Pnt2d

    :param Cy:
    :type Cy: gp_Cylinder
    :param L:
    :type L: gp_Lin
    :rtype: gp_Lin2d

    :param Cy:
    :type Cy: gp_Cylinder
    :param Ci:
    :type Ci: gp_Circ
    :rtype: gp_Lin2d

    :param Co:
    :type Co: gp_Cone
    :param P:
    :type P: gp_Pnt
    :rtype: gp_Pnt2d

    :param Co:
    :type Co: gp_Cone
    :param L:
    :type L: gp_Lin
    :rtype: gp_Lin2d

    :param Co:
    :type Co: gp_Cone
    :param Ci:
    :type Ci: gp_Circ
    :rtype: gp_Lin2d

    :param Sp:
    :type Sp: gp_Sphere
    :param P:
    :type P: gp_Pnt
    :rtype: gp_Pnt2d

    :param Sp:
    :type Sp: gp_Sphere
    :param Ci:
    :type Ci: gp_Circ
    :rtype: gp_Lin2d

    :param To:
    :type To: gp_Torus
    :param P:
    :type P: gp_Pnt
    :rtype: gp_Pnt2d

    :param To:
    :type To: gp_Torus
    :param Ci:
    :type Ci: gp_Circ
    :rtype: gp_Lin2d

    """
    return _ProjLib.projlib_Project(*args)

class ProjLib_CompProjectedCurve(OCC.Adaptor2d.Adaptor2d_Curve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        * try to find all solutions

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param TolU:
        :type TolU: float
        :param TolV:
        :type TolV: float
        :rtype: None

        * this constructor tries to optimize the search using the assamption that maximum distance between surface and curve less or equal then MaxDist. if MaxDist < 0 then algorithm works as above.

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param TolU:
        :type TolU: float
        :param TolV:
        :type TolV: float
        :param MaxDist:
        :type MaxDist: float
        :rtype: None

        """
        _ProjLib.ProjLib_CompProjectedCurve_swiginit(self, _ProjLib.new_ProjLib_CompProjectedCurve(*args))

    def Init(self, *args):
        """
        * computes a set of projected point and determine the continuous parts of the projected curves. The points corresponding to a projection on the bounds of the surface are included in this set of points.

        :rtype: None

        """
        return _ProjLib.ProjLib_CompProjectedCurve_Init(self, *args)


    def Load(self, *args):
        """
        * Changes the surface.

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: None

        * Changes the curve.

        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :rtype: None

        """
        return _ProjLib.ProjLib_CompProjectedCurve_Load(self, *args)


    def GetSurface(self, *args):
        """
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _ProjLib.ProjLib_CompProjectedCurve_GetSurface(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: Handle_Adaptor3d_HCurve

        """
        return _ProjLib.ProjLib_CompProjectedCurve_GetCurve(self, *args)


    def GetTolerance(self, *args):
        """
        :param TolU:
        :type TolU: float &
        :param TolV:
        :type TolV: float &
        :rtype: None

        """
        return _ProjLib.ProjLib_CompProjectedCurve_GetTolerance(self, *args)


    def NbCurves(self, *args):
        """
        * returns the number of continuous part of the projected curve

        :rtype: int

        """
        return _ProjLib.ProjLib_CompProjectedCurve_NbCurves(self, *args)


    def Bounds(self, *args):
        """
        * returns the bounds of the continuous part corresponding to Index

        :param Index:
        :type Index: int
        :param Udeb:
        :type Udeb: float &
        :param Ufin:
        :type Ufin: float &
        :rtype: None

        """
        return _ProjLib.ProjLib_CompProjectedCurve_Bounds(self, *args)


    def IsSinglePnt(self, *args):
        """
        * returns True if part of projection with number Index is a single point and writes its coordinats in P

        :param Index:
        :type Index: int
        :param P:
        :type P: gp_Pnt2d
        :rtype: bool

        """
        return _ProjLib.ProjLib_CompProjectedCurve_IsSinglePnt(self, *args)


    def IsUIso(self, *args):
        """
        * returns True if part of projection with number Index is an u-isoparametric curve of input surface

        :param Index:
        :type Index: int
        :param U:
        :type U: float &
        :rtype: bool

        """
        return _ProjLib.ProjLib_CompProjectedCurve_IsUIso(self, *args)


    def IsVIso(self, *args):
        """
        * returns True if part of projection with number Index is an v-isoparametric curve of input surface

        :param Index:
        :type Index: int
        :param V:
        :type V: float &
        :rtype: bool

        """
        return _ProjLib.ProjLib_CompProjectedCurve_IsVIso(self, *args)


    def MaxDistance(self, *args):
        """
        * returns the maximum distance between curve to project and surface

        :param Index:
        :type Index: int
        :rtype: float

        """
        return _ProjLib.ProjLib_CompProjectedCurve_MaxDistance(self, *args)


    def GetSequence(self, *args):
        """
        :rtype: Handle_ProjLib_HSequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_CompProjectedCurve_GetSequence(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_CompProjectedCurve.Init = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_Init, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.Load = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_Load, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetSurface = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetSurface, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetCurve = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetCurve, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetTolerance = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetTolerance, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.NbCurves = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_NbCurves, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.Bounds = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_Bounds, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.IsSinglePnt = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_IsSinglePnt, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.IsUIso = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_IsUIso, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.IsVIso = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_IsVIso, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.MaxDistance = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_MaxDistance, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetSequence = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetSequence, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve._kill_pointed = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve__kill_pointed, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve_swigregister = _ProjLib.ProjLib_CompProjectedCurve_swigregister
ProjLib_CompProjectedCurve_swigregister(ProjLib_CompProjectedCurve)

class ProjLib_ComputeApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * <Tol> is the tolerance with which the approximation is performed.

        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        _ProjLib.ProjLib_ComputeApprox_swiginit(self, _ProjLib.new_ProjLib_ComputeApprox(*args))

    def BSpline(self, *args):
        """
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ProjLib.ProjLib_ComputeApprox_BSpline(self, *args)


    def Bezier(self, *args):
        """
        :rtype: Handle_Geom2d_BezierCurve

        """
        return _ProjLib.ProjLib_ComputeApprox_Bezier(self, *args)


    def Tolerance(self, *args):
        """
        * returns the reached Tolerance.

        :rtype: float

        """
        return _ProjLib.ProjLib_ComputeApprox_Tolerance(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_ComputeApprox.BSpline = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_BSpline, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox.Bezier = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_Bezier, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox.Tolerance = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_Tolerance, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox._kill_pointed = new_instancemethod(_ProjLib.ProjLib_ComputeApprox__kill_pointed, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox_swigregister = _ProjLib.ProjLib_ComputeApprox_swigregister
ProjLib_ComputeApprox_swigregister(ProjLib_ComputeApprox)

class ProjLib_ComputeApproxOnPolarSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol: default value is 1.0e-4
        :type Tol: float
        :rtype: None

        :param InitCurve2d:
        :type InitCurve2d: Handle_Adaptor2d_HCurve2d &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        :param InitCurve2d:
        :type InitCurve2d: Handle_Adaptor2d_HCurve2d &
        :param InitCurve2dBis:
        :type InitCurve2dBis: Handle_Adaptor2d_HCurve2d &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        _ProjLib.ProjLib_ComputeApproxOnPolarSurface_swiginit(self, _ProjLib.new_ProjLib_ComputeApproxOnPolarSurface(*args))

    def Perform(self, *args):
        """
        :param InitCurve2d:
        :type InitCurve2d: Handle_Adaptor2d_HCurve2d &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_Perform(self, *args)


    def BuildInitialCurve2d(self, *args):
        """
        :param Curve:
        :type Curve: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_BuildInitialCurve2d(self, *args)


    def ProjectUsingInitialCurve2d(self, *args):
        """
        :param Curve:
        :type Curve: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param InitCurve2d:
        :type InitCurve2d: Handle_Adaptor2d_HCurve2d &
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_ProjectUsingInitialCurve2d(self, *args)


    def BSpline(self, *args):
        """
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_BSpline(self, *args)


    def Curve2d(self, *args):
        """
        :rtype: Handle_Geom2d_Curve

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_Curve2d(self, *args)


    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_IsDone(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_ComputeApproxOnPolarSurface.Perform = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_Perform, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.BuildInitialCurve2d = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_BuildInitialCurve2d, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.ProjectUsingInitialCurve2d = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_ProjectUsingInitialCurve2d, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.BSpline = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_BSpline, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.Curve2d = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_Curve2d, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.IsDone = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_IsDone, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface._kill_pointed = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface__kill_pointed, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface_swigregister = _ProjLib.ProjLib_ComputeApproxOnPolarSurface_swigregister
ProjLib_ComputeApproxOnPolarSurface_swigregister(ProjLib_ComputeApproxOnPolarSurface)

class ProjLib_HCompProjectedCurve(OCC.Adaptor2d.Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param C:
        :type C: ProjLib_CompProjectedCurve &
        :rtype: None

        """
        _ProjLib.ProjLib_HCompProjectedCurve_swiginit(self, _ProjLib.new_ProjLib_HCompProjectedCurve(*args))

    def Set(self, *args):
        """
        :param C:
        :type C: ProjLib_CompProjectedCurve &
        :rtype: None

        """
        return _ProjLib.ProjLib_HCompProjectedCurve_Set(self, *args)


    def ChangeCurve2d(self, *args):
        """
        :rtype: ProjLib_CompProjectedCurve

        """
        return _ProjLib.ProjLib_HCompProjectedCurve_ChangeCurve2d(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(ProjLib_HCompProjectedCurve self)"""
        return _ProjLib.ProjLib_HCompProjectedCurve__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(ProjLib_HCompProjectedCurve self) -> Handle_ProjLib_HCompProjectedCurve"""
        return _ProjLib.ProjLib_HCompProjectedCurve_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_HCompProjectedCurve.Set = new_instancemethod(_ProjLib.ProjLib_HCompProjectedCurve_Set, None, ProjLib_HCompProjectedCurve)
ProjLib_HCompProjectedCurve.ChangeCurve2d = new_instancemethod(_ProjLib.ProjLib_HCompProjectedCurve_ChangeCurve2d, None, ProjLib_HCompProjectedCurve)
ProjLib_HCompProjectedCurve._kill_pointed = new_instancemethod(_ProjLib.ProjLib_HCompProjectedCurve__kill_pointed, None, ProjLib_HCompProjectedCurve)
ProjLib_HCompProjectedCurve.GetHandle = new_instancemethod(_ProjLib.ProjLib_HCompProjectedCurve_GetHandle, None, ProjLib_HCompProjectedCurve)
ProjLib_HCompProjectedCurve_swigregister = _ProjLib.ProjLib_HCompProjectedCurve_swigregister
ProjLib_HCompProjectedCurve_swigregister(ProjLib_HCompProjectedCurve)

class Handle_ProjLib_HCompProjectedCurve(OCC.Adaptor2d.Handle_Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ProjLib.Handle_ProjLib_HCompProjectedCurve_swiginit(self, _ProjLib.new_Handle_ProjLib_HCompProjectedCurve(*args))
    DownCast = staticmethod(_ProjLib.Handle_ProjLib_HCompProjectedCurve_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_ProjLib_HCompProjectedCurve.Nullify = new_instancemethod(_ProjLib.Handle_ProjLib_HCompProjectedCurve_Nullify, None, Handle_ProjLib_HCompProjectedCurve)
Handle_ProjLib_HCompProjectedCurve.IsNull = new_instancemethod(_ProjLib.Handle_ProjLib_HCompProjectedCurve_IsNull, None, Handle_ProjLib_HCompProjectedCurve)
Handle_ProjLib_HCompProjectedCurve.GetObject = new_instancemethod(_ProjLib.Handle_ProjLib_HCompProjectedCurve_GetObject, None, Handle_ProjLib_HCompProjectedCurve)
Handle_ProjLib_HCompProjectedCurve._kill_pointed = new_instancemethod(_ProjLib.Handle_ProjLib_HCompProjectedCurve__kill_pointed, None, Handle_ProjLib_HCompProjectedCurve)
Handle_ProjLib_HCompProjectedCurve_swigregister = _ProjLib.Handle_ProjLib_HCompProjectedCurve_swigregister
Handle_ProjLib_HCompProjectedCurve_swigregister(Handle_ProjLib_HCompProjectedCurve)

def Handle_ProjLib_HCompProjectedCurve_DownCast(AnObject):
    return _ProjLib.Handle_ProjLib_HCompProjectedCurve_DownCast(AnObject)
Handle_ProjLib_HCompProjectedCurve_DownCast = _ProjLib.Handle_ProjLib_HCompProjectedCurve_DownCast

class ProjLib_HProjectedCurve(OCC.Adaptor2d.Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param C:
        :type C: ProjLib_ProjectedCurve &
        :rtype: None

        """
        _ProjLib.ProjLib_HProjectedCurve_swiginit(self, _ProjLib.new_ProjLib_HProjectedCurve(*args))

    def Set(self, *args):
        """
        :param C:
        :type C: ProjLib_ProjectedCurve &
        :rtype: None

        """
        return _ProjLib.ProjLib_HProjectedCurve_Set(self, *args)


    def ChangeCurve2d(self, *args):
        """
        :rtype: ProjLib_ProjectedCurve

        """
        return _ProjLib.ProjLib_HProjectedCurve_ChangeCurve2d(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(ProjLib_HProjectedCurve self)"""
        return _ProjLib.ProjLib_HProjectedCurve__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(ProjLib_HProjectedCurve self) -> Handle_ProjLib_HProjectedCurve"""
        return _ProjLib.ProjLib_HProjectedCurve_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_HProjectedCurve.Set = new_instancemethod(_ProjLib.ProjLib_HProjectedCurve_Set, None, ProjLib_HProjectedCurve)
ProjLib_HProjectedCurve.ChangeCurve2d = new_instancemethod(_ProjLib.ProjLib_HProjectedCurve_ChangeCurve2d, None, ProjLib_HProjectedCurve)
ProjLib_HProjectedCurve._kill_pointed = new_instancemethod(_ProjLib.ProjLib_HProjectedCurve__kill_pointed, None, ProjLib_HProjectedCurve)
ProjLib_HProjectedCurve.GetHandle = new_instancemethod(_ProjLib.ProjLib_HProjectedCurve_GetHandle, None, ProjLib_HProjectedCurve)
ProjLib_HProjectedCurve_swigregister = _ProjLib.ProjLib_HProjectedCurve_swigregister
ProjLib_HProjectedCurve_swigregister(ProjLib_HProjectedCurve)

class Handle_ProjLib_HProjectedCurve(OCC.Adaptor2d.Handle_Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ProjLib.Handle_ProjLib_HProjectedCurve_swiginit(self, _ProjLib.new_Handle_ProjLib_HProjectedCurve(*args))
    DownCast = staticmethod(_ProjLib.Handle_ProjLib_HProjectedCurve_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_ProjLib_HProjectedCurve.Nullify = new_instancemethod(_ProjLib.Handle_ProjLib_HProjectedCurve_Nullify, None, Handle_ProjLib_HProjectedCurve)
Handle_ProjLib_HProjectedCurve.IsNull = new_instancemethod(_ProjLib.Handle_ProjLib_HProjectedCurve_IsNull, None, Handle_ProjLib_HProjectedCurve)
Handle_ProjLib_HProjectedCurve.GetObject = new_instancemethod(_ProjLib.Handle_ProjLib_HProjectedCurve_GetObject, None, Handle_ProjLib_HProjectedCurve)
Handle_ProjLib_HProjectedCurve._kill_pointed = new_instancemethod(_ProjLib.Handle_ProjLib_HProjectedCurve__kill_pointed, None, Handle_ProjLib_HProjectedCurve)
Handle_ProjLib_HProjectedCurve_swigregister = _ProjLib.Handle_ProjLib_HProjectedCurve_swigregister
Handle_ProjLib_HProjectedCurve_swigregister(Handle_ProjLib_HProjectedCurve)

def Handle_ProjLib_HProjectedCurve_DownCast(AnObject):
    return _ProjLib.Handle_ProjLib_HProjectedCurve_DownCast(AnObject)
Handle_ProjLib_HProjectedCurve_DownCast = _ProjLib.Handle_ProjLib_HProjectedCurve_DownCast

class ProjLib_HSequenceOfHSequenceOfPnt(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_swiginit(self, _ProjLib.new_ProjLib_HSequenceOfHSequenceOfPnt(*args))

    def IsEmpty(self, *args):
        """
        :rtype: bool

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_IsEmpty(self, *args)


    def Length(self, *args):
        """
        :rtype: int

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Length(self, *args)


    def Clear(self, *args):
        """
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Clear(self, *args)


    def Append(self, *args):
        """
        :param anItem:
        :type anItem: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param aSequence:
        :type aSequence: Handle_ProjLib_HSequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Append(self, *args)


    def Prepend(self, *args):
        """
        :param anItem:
        :type anItem: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param aSequence:
        :type aSequence: Handle_ProjLib_HSequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Prepend(self, *args)


    def Reverse(self, *args):
        """
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Reverse(self, *args)


    def InsertBefore(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param anIndex:
        :type anIndex: int
        :param aSequence:
        :type aSequence: Handle_ProjLib_HSequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param anIndex:
        :type anIndex: int
        :param aSequence:
        :type aSequence: Handle_ProjLib_HSequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_InsertAfter(self, *args)


    def Exchange(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anOtherIndex:
        :type anOtherIndex: int
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Exchange(self, *args)


    def Split(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_ProjLib_HSequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Split(self, *args)


    def SetValue(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_SetValue(self, *args)


    def Value(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Value(self, *args)


    def ChangeValue(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ChangeValue(self, *args)


    def Remove(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: None

        :param fromIndex:
        :type fromIndex: int
        :param toIndex:
        :type toIndex: int
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Remove(self, *args)


    def Sequence(self, *args):
        """
        :rtype: ProjLib_SequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Sequence(self, *args)


    def ChangeSequence(self, *args):
        """
        :rtype: ProjLib_SequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ChangeSequence(self, *args)


    def ShallowCopy(self, *args):
        """
        :rtype: Handle_ProjLib_HSequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ShallowCopy(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(ProjLib_HSequenceOfHSequenceOfPnt self)"""
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(ProjLib_HSequenceOfHSequenceOfPnt self) -> Handle_ProjLib_HSequenceOfHSequenceOfPnt"""
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_HSequenceOfHSequenceOfPnt.IsEmpty = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_IsEmpty, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Length = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Length, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Clear = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Clear, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Append = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Append, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Prepend = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Prepend, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Reverse = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Reverse, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.InsertBefore = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_InsertBefore, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.InsertAfter = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_InsertAfter, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Exchange = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Exchange, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Split = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Split, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.SetValue = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_SetValue, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Value = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Value, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.ChangeValue = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ChangeValue, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Remove = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Remove, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Sequence = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Sequence, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.ChangeSequence = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ChangeSequence, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.ShallowCopy = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ShallowCopy, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt._kill_pointed = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt__kill_pointed, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.GetHandle = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_GetHandle, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt_swigregister = _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_swigregister
ProjLib_HSequenceOfHSequenceOfPnt_swigregister(ProjLib_HSequenceOfHSequenceOfPnt)

class Handle_ProjLib_HSequenceOfHSequenceOfPnt(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_swiginit(self, _ProjLib.new_Handle_ProjLib_HSequenceOfHSequenceOfPnt(*args))
    DownCast = staticmethod(_ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_ProjLib_HSequenceOfHSequenceOfPnt.Nullify = new_instancemethod(_ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_Nullify, None, Handle_ProjLib_HSequenceOfHSequenceOfPnt)
Handle_ProjLib_HSequenceOfHSequenceOfPnt.IsNull = new_instancemethod(_ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_IsNull, None, Handle_ProjLib_HSequenceOfHSequenceOfPnt)
Handle_ProjLib_HSequenceOfHSequenceOfPnt.GetObject = new_instancemethod(_ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_GetObject, None, Handle_ProjLib_HSequenceOfHSequenceOfPnt)
Handle_ProjLib_HSequenceOfHSequenceOfPnt._kill_pointed = new_instancemethod(_ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt__kill_pointed, None, Handle_ProjLib_HSequenceOfHSequenceOfPnt)
Handle_ProjLib_HSequenceOfHSequenceOfPnt_swigregister = _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_swigregister
Handle_ProjLib_HSequenceOfHSequenceOfPnt_swigregister(Handle_ProjLib_HSequenceOfHSequenceOfPnt)

def Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast(AnObject):
    return _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast(AnObject)
Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast = _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast

class ProjLib_PrjFunc(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param C:
        :type C: Adaptor3d_CurvePtr &
        :param FixVal:
        :type FixVal: float
        :param S:
        :type S: Adaptor3d_SurfacePtr &
        :param Fix:
        :type Fix: int
        :rtype: None

        """
        _ProjLib.ProjLib_PrjFunc_swiginit(self, _ProjLib.new_ProjLib_PrjFunc(*args))

    def NbVariables(self, *args):
        """
        * returns the number of variables of the function.

        :rtype: int

        """
        return _ProjLib.ProjLib_PrjFunc_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _ProjLib.ProjLib_PrjFunc_NbEquations(self, *args)


    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _ProjLib.ProjLib_PrjFunc_Value(self, *args)


    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _ProjLib.ProjLib_PrjFunc_Derivatives(self, *args)


    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _ProjLib.ProjLib_PrjFunc_Values(self, *args)


    def Solution(self, *args):
        """
        * returns point on surface

        :rtype: gp_Pnt2d

        """
        return _ProjLib.ProjLib_PrjFunc_Solution(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_PrjFunc.NbVariables = new_instancemethod(_ProjLib.ProjLib_PrjFunc_NbVariables, None, ProjLib_PrjFunc)
ProjLib_PrjFunc.NbEquations = new_instancemethod(_ProjLib.ProjLib_PrjFunc_NbEquations, None, ProjLib_PrjFunc)
ProjLib_PrjFunc.Value = new_instancemethod(_ProjLib.ProjLib_PrjFunc_Value, None, ProjLib_PrjFunc)
ProjLib_PrjFunc.Derivatives = new_instancemethod(_ProjLib.ProjLib_PrjFunc_Derivatives, None, ProjLib_PrjFunc)
ProjLib_PrjFunc.Values = new_instancemethod(_ProjLib.ProjLib_PrjFunc_Values, None, ProjLib_PrjFunc)
ProjLib_PrjFunc.Solution = new_instancemethod(_ProjLib.ProjLib_PrjFunc_Solution, None, ProjLib_PrjFunc)
ProjLib_PrjFunc._kill_pointed = new_instancemethod(_ProjLib.ProjLib_PrjFunc__kill_pointed, None, ProjLib_PrjFunc)
ProjLib_PrjFunc_swigregister = _ProjLib.ProjLib_PrjFunc_swigregister
ProjLib_PrjFunc_swigregister(ProjLib_PrjFunc)

class ProjLib_PrjResolve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param C:
        :type C: Adaptor3d_Curve &
        :param S:
        :type S: Adaptor3d_Surface &
        :param Fix:
        :type Fix: int
        :rtype: None

        """
        _ProjLib.ProjLib_PrjResolve_swiginit(self, _ProjLib.new_ProjLib_PrjResolve(*args))

    def Perform(self, *args):
        """
        * Calculates the ort from C(t) to S with a close point. The close point is defined by the parameter values U0 and V0. The function F(u,v)=distance(S(u,v),C(t)) has an extremum when gradient(F)=0. The algorithm searchs a zero near the close point.

        :param t:
        :type t: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param Tol:
        :type Tol: gp_Pnt2d
        :param Inf:
        :type Inf: gp_Pnt2d
        :param Sup:
        :type Sup: gp_Pnt2d
        :param FTol: default value is -1
        :type FTol: float
        :param StrictInside: default value is Standard_False
        :type StrictInside: bool
        :rtype: None

        """
        return _ProjLib.ProjLib_PrjResolve_Perform(self, *args)


    def IsDone(self, *args):
        """
        * Returns True if the distance is found.

        :rtype: bool

        """
        return _ProjLib.ProjLib_PrjResolve_IsDone(self, *args)


    def Solution(self, *args):
        """
        * Returns the point of the extremum distance.

        :rtype: gp_Pnt2d

        """
        return _ProjLib.ProjLib_PrjResolve_Solution(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_PrjResolve.Perform = new_instancemethod(_ProjLib.ProjLib_PrjResolve_Perform, None, ProjLib_PrjResolve)
ProjLib_PrjResolve.IsDone = new_instancemethod(_ProjLib.ProjLib_PrjResolve_IsDone, None, ProjLib_PrjResolve)
ProjLib_PrjResolve.Solution = new_instancemethod(_ProjLib.ProjLib_PrjResolve_Solution, None, ProjLib_PrjResolve)
ProjLib_PrjResolve._kill_pointed = new_instancemethod(_ProjLib.ProjLib_PrjResolve__kill_pointed, None, ProjLib_PrjResolve)
ProjLib_PrjResolve_swigregister = _ProjLib.ProjLib_PrjResolve_swigregister
ProjLib_PrjResolve_swigregister(ProjLib_PrjResolve)

class ProjLib_ProjectOnPlane(OCC.Adaptor3d.Adaptor3d_Curve):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty constructor.

        :rtype: None

        * The projection will be normal to the Plane defined by the Ax3 <Pl>.

        :param Pl:
        :type Pl: gp_Ax3
        :rtype: None

        * The projection will be along the direction <D> on the plane defined by the Ax3 <Pl>. raises if the direction <D> is parallel to the plane <Pl>.

        :param Pl:
        :type Pl: gp_Ax3
        :param D:
        :type D: gp_Dir
        :rtype: None

        """
        _ProjLib.ProjLib_ProjectOnPlane_swiginit(self, _ProjLib.new_ProjLib_ProjectOnPlane(*args))

    def Load(self, *args):
        """
        * Sets the Curve and perform the projection. if <KeepParametrization> is true, the parametrization of the Projected Curve <PC> will be the same as the parametrization of the initial curve <C>. It meens: proj(C(u)) = PC(u) for each u. Otherwize, the parametrization may change.

        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param Tolerance:
        :type Tolerance: float
        :param KeepParametrization: default value is Standard_True
        :type KeepParametrization: bool
        :rtype: None

        """
        return _ProjLib.ProjLib_ProjectOnPlane_Load(self, *args)


    def GetPlane(self, *args):
        """
        :rtype: gp_Ax3

        """
        return _ProjLib.ProjLib_ProjectOnPlane_GetPlane(self, *args)


    def GetDirection(self, *args):
        """
        :rtype: gp_Dir

        """
        return _ProjLib.ProjLib_ProjectOnPlane_GetDirection(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: Handle_Adaptor3d_HCurve

        """
        return _ProjLib.ProjLib_ProjectOnPlane_GetCurve(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_ProjectOnPlane.Load = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_Load, None, ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane.GetPlane = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_GetPlane, None, ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane.GetDirection = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_GetDirection, None, ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane.GetCurve = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_GetCurve, None, ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane._kill_pointed = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane__kill_pointed, None, ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane_swigregister = _ProjLib.ProjLib_ProjectOnPlane_swigregister
ProjLib_ProjectOnPlane_swigregister(ProjLib_ProjectOnPlane)

class ProjLib_ProjectOnSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Create an empty projector.

        :rtype: None

        * Create a projector normaly to the surface <S>.

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        _ProjLib.ProjLib_ProjectOnSurface_swiginit(self, _ProjLib.new_ProjLib_ProjectOnSurface(*args))

    def Delete(self, *args):
        """
        :rtype: void

        """
        return _ProjLib.ProjLib_ProjectOnSurface_Delete(self, *args)


    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _ProjLib.ProjLib_ProjectOnSurface_IsDone(self, *args)


    def BSpline(self, *args):
        """
        :rtype: Handle_Geom_BSplineCurve

        """
        return _ProjLib.ProjLib_ProjectOnSurface_BSpline(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_ProjectOnSurface.Delete = new_instancemethod(_ProjLib.ProjLib_ProjectOnSurface_Delete, None, ProjLib_ProjectOnSurface)
ProjLib_ProjectOnSurface.IsDone = new_instancemethod(_ProjLib.ProjLib_ProjectOnSurface_IsDone, None, ProjLib_ProjectOnSurface)
ProjLib_ProjectOnSurface.BSpline = new_instancemethod(_ProjLib.ProjLib_ProjectOnSurface_BSpline, None, ProjLib_ProjectOnSurface)
ProjLib_ProjectOnSurface._kill_pointed = new_instancemethod(_ProjLib.ProjLib_ProjectOnSurface__kill_pointed, None, ProjLib_ProjectOnSurface)
ProjLib_ProjectOnSurface_swigregister = _ProjLib.ProjLib_ProjectOnSurface_swigregister
ProjLib_ProjectOnSurface_swigregister(ProjLib_ProjectOnSurface)

class ProjLib_ProjectedCurve(OCC.Adaptor2d.Adaptor2d_Curve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: None

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :rtype: None

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        _ProjLib.ProjLib_ProjectedCurve_swiginit(self, _ProjLib.new_ProjLib_ProjectedCurve(*args))

    def GetSurface(self, *args):
        """
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _ProjLib.ProjLib_ProjectedCurve_GetSurface(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: Handle_Adaptor3d_HCurve

        """
        return _ProjLib.ProjLib_ProjectedCurve_GetCurve(self, *args)


    def GetTolerance(self, *args):
        """
        * returns the tolerance reached if an approximation is Done.

        :rtype: float

        """
        return _ProjLib.ProjLib_ProjectedCurve_GetTolerance(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_ProjectedCurve.GetSurface = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_GetSurface, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.GetCurve = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_GetCurve, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.GetTolerance = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_GetTolerance, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve._kill_pointed = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve__kill_pointed, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve_swigregister = _ProjLib.ProjLib_ProjectedCurve_swigregister
ProjLib_ProjectedCurve_swigregister(ProjLib_ProjectedCurve)

class ProjLib_Projector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Sets the type to OtherCurve

        :rtype: None

        """
        _ProjLib.ProjLib_Projector_swiginit(self, _ProjLib.new_ProjLib_Projector(*args))

    def Delete(self, *args):
        """
        :rtype: void

        """
        return _ProjLib.ProjLib_Projector_Delete(self, *args)


    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _ProjLib.ProjLib_Projector_IsDone(self, *args)


    def Done(self, *args):
        """
        * Set isDone = Standard_True;

        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_Done(self, *args)


    def GetType(self, *args):
        """
        :rtype: GeomAbs_CurveType

        """
        return _ProjLib.ProjLib_Projector_GetType(self, *args)


    def SetBSpline(self, *args):
        """
        :param C:
        :type C: Handle_Geom2d_BSplineCurve &
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_SetBSpline(self, *args)


    def SetBezier(self, *args):
        """
        :param C:
        :type C: Handle_Geom2d_BezierCurve &
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_SetBezier(self, *args)


    def SetType(self, *args):
        """
        :param Type:
        :type Type: GeomAbs_CurveType
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_SetType(self, *args)


    def IsPeriodic(self, *args):
        """
        :rtype: bool

        """
        return _ProjLib.ProjLib_Projector_IsPeriodic(self, *args)


    def SetPeriodic(self, *args):
        """
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_SetPeriodic(self, *args)


    def Line(self, *args):
        """
        :rtype: gp_Lin2d

        """
        return _ProjLib.ProjLib_Projector_Line(self, *args)


    def Circle(self, *args):
        """
        :rtype: gp_Circ2d

        """
        return _ProjLib.ProjLib_Projector_Circle(self, *args)


    def Ellipse(self, *args):
        """
        :rtype: gp_Elips2d

        """
        return _ProjLib.ProjLib_Projector_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        :rtype: gp_Hypr2d

        """
        return _ProjLib.ProjLib_Projector_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        :rtype: gp_Parab2d

        """
        return _ProjLib.ProjLib_Projector_Parabola(self, *args)


    def Bezier(self, *args):
        """
        :rtype: Handle_Geom2d_BezierCurve

        """
        return _ProjLib.ProjLib_Projector_Bezier(self, *args)


    def BSpline(self, *args):
        """
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ProjLib.ProjLib_Projector_BSpline(self, *args)


    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Projector_Project(self, *args)


    def UFrame(self, *args):
        """
        * Translates the 2d curve to set the part of the curve [CFirst, CLast] in the range [ UFirst, UFirst + Period [

        :param CFirst:
        :type CFirst: float
        :param CLast:
        :type CLast: float
        :param UFirst:
        :type UFirst: float
        :param Period:
        :type Period: float
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_UFrame(self, *args)


    def VFrame(self, *args):
        """
        * Translates the 2d curve to set the part of the curve [CFirst, CLast] in the range [ VFirst, VFirst + Period [

        :param CFirst:
        :type CFirst: float
        :param CLast:
        :type CLast: float
        :param VFirst:
        :type VFirst: float
        :param Period:
        :type Period: float
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_VFrame(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_Projector.Delete = new_instancemethod(_ProjLib.ProjLib_Projector_Delete, None, ProjLib_Projector)
ProjLib_Projector.IsDone = new_instancemethod(_ProjLib.ProjLib_Projector_IsDone, None, ProjLib_Projector)
ProjLib_Projector.Done = new_instancemethod(_ProjLib.ProjLib_Projector_Done, None, ProjLib_Projector)
ProjLib_Projector.GetType = new_instancemethod(_ProjLib.ProjLib_Projector_GetType, None, ProjLib_Projector)
ProjLib_Projector.SetBSpline = new_instancemethod(_ProjLib.ProjLib_Projector_SetBSpline, None, ProjLib_Projector)
ProjLib_Projector.SetBezier = new_instancemethod(_ProjLib.ProjLib_Projector_SetBezier, None, ProjLib_Projector)
ProjLib_Projector.SetType = new_instancemethod(_ProjLib.ProjLib_Projector_SetType, None, ProjLib_Projector)
ProjLib_Projector.IsPeriodic = new_instancemethod(_ProjLib.ProjLib_Projector_IsPeriodic, None, ProjLib_Projector)
ProjLib_Projector.SetPeriodic = new_instancemethod(_ProjLib.ProjLib_Projector_SetPeriodic, None, ProjLib_Projector)
ProjLib_Projector.Line = new_instancemethod(_ProjLib.ProjLib_Projector_Line, None, ProjLib_Projector)
ProjLib_Projector.Circle = new_instancemethod(_ProjLib.ProjLib_Projector_Circle, None, ProjLib_Projector)
ProjLib_Projector.Ellipse = new_instancemethod(_ProjLib.ProjLib_Projector_Ellipse, None, ProjLib_Projector)
ProjLib_Projector.Hyperbola = new_instancemethod(_ProjLib.ProjLib_Projector_Hyperbola, None, ProjLib_Projector)
ProjLib_Projector.Parabola = new_instancemethod(_ProjLib.ProjLib_Projector_Parabola, None, ProjLib_Projector)
ProjLib_Projector.Bezier = new_instancemethod(_ProjLib.ProjLib_Projector_Bezier, None, ProjLib_Projector)
ProjLib_Projector.BSpline = new_instancemethod(_ProjLib.ProjLib_Projector_BSpline, None, ProjLib_Projector)
ProjLib_Projector.Project = new_instancemethod(_ProjLib.ProjLib_Projector_Project, None, ProjLib_Projector)
ProjLib_Projector.UFrame = new_instancemethod(_ProjLib.ProjLib_Projector_UFrame, None, ProjLib_Projector)
ProjLib_Projector.VFrame = new_instancemethod(_ProjLib.ProjLib_Projector_VFrame, None, ProjLib_Projector)
ProjLib_Projector._kill_pointed = new_instancemethod(_ProjLib.ProjLib_Projector__kill_pointed, None, ProjLib_Projector)
ProjLib_Projector_swigregister = _ProjLib.ProjLib_Projector_swigregister
ProjLib_Projector_swigregister(ProjLib_Projector)

class ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: Handle_TColgp_HSequenceOfPnt
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swiginit(self, _ProjLib.new_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt(*args))

    def Value(self, *args):
        """
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_Value(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt self)"""
        return _ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt self) -> Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt"""
        return _ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt.Value = new_instancemethod(_ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_Value, None, ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt._kill_pointed = new_instancemethod(_ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt__kill_pointed, None, ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt.GetHandle = new_instancemethod(_ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_GetHandle, None, ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister = _ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister
ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister(ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)

class Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swiginit(self, _ProjLib.new_Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt(*args))
    DownCast = staticmethod(_ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt.Nullify = new_instancemethod(_ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_Nullify, None, Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt.IsNull = new_instancemethod(_ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_IsNull, None, Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt.GetObject = new_instancemethod(_ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_GetObject, None, Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt._kill_pointed = new_instancemethod(_ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt__kill_pointed, None, Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister = _ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister(Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)

def Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_DownCast(AnObject):
    return _ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_DownCast(AnObject)
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_DownCast = _ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_DownCast

class ProjLib_SequenceOfHSequenceOfPnt(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_swiginit(self, _ProjLib.new_ProjLib_SequenceOfHSequenceOfPnt(*args))

    def Clear(self, *args):
        """
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Clear(self, *args)


    def Assign(self, *args):
        """
        :param Other:
        :type Other: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: ProjLib_SequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Assign(self, *args)


    def Set(self, *args):
        """
        :param Other:
        :type Other: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: ProjLib_SequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Set(self, *args)


    def Append(self, *args):
        """
        :param T:
        :type T: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param S:
        :type S: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Append(self, *args)


    def Prepend(self, *args):
        """
        :param T:
        :type T: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param S:
        :type S: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_InsertAfter(self, *args)


    def First(self, *args):
        """
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_First(self, *args)


    def Last(self, *args):
        """
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Last(self, *args)


    def Split(self, *args):
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Split(self, *args)


    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Value(self, *args)


    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_SetValue(self, *args)


    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_ChangeValue(self, *args)


    def Remove(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Remove(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_SequenceOfHSequenceOfPnt.Clear = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Clear, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Assign = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Assign, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Set = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Set, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Append = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Append, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Prepend = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Prepend, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.InsertBefore = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_InsertBefore, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.InsertAfter = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_InsertAfter, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.First = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_First, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Last = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Last, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Split = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Split, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Value = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Value, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.SetValue = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_SetValue, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.ChangeValue = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_ChangeValue, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Remove = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Remove, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt._kill_pointed = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt__kill_pointed, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt_swigregister = _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_swigregister
ProjLib_SequenceOfHSequenceOfPnt_swigregister(ProjLib_SequenceOfHSequenceOfPnt)

class ProjLib_Cone(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Undefined projection.

        :rtype: None

        * Projection on the cone <Co>.

        :param Co:
        :type Co: gp_Cone
        :rtype: None

        * Projection of the line <L> on the cone <Co>.

        :param Co:
        :type Co: gp_Cone
        :param L:
        :type L: gp_Lin
        :rtype: None

        * Projection of the circle <C> on the cone <Co>.

        :param Co:
        :type Co: gp_Cone
        :param C:
        :type C: gp_Circ
        :rtype: None

        """
        _ProjLib.ProjLib_Cone_swiginit(self, _ProjLib.new_ProjLib_Cone(*args))

    def Init(self, *args):
        """
        :param Co:
        :type Co: gp_Cone
        :rtype: None

        """
        return _ProjLib.ProjLib_Cone_Init(self, *args)


    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Cone_Project(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_Cone.Init = new_instancemethod(_ProjLib.ProjLib_Cone_Init, None, ProjLib_Cone)
ProjLib_Cone.Project = new_instancemethod(_ProjLib.ProjLib_Cone_Project, None, ProjLib_Cone)
ProjLib_Cone._kill_pointed = new_instancemethod(_ProjLib.ProjLib_Cone__kill_pointed, None, ProjLib_Cone)
ProjLib_Cone_swigregister = _ProjLib.ProjLib_Cone_swigregister
ProjLib_Cone_swigregister(ProjLib_Cone)

class ProjLib_Cylinder(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Undefined projection.

        :rtype: None

        * Projection on the cylinder <Cyl>.

        :param Cyl:
        :type Cyl: gp_Cylinder
        :rtype: None

        * Projection of the line <L> on the cylinder <Cyl>.

        :param Cyl:
        :type Cyl: gp_Cylinder
        :param L:
        :type L: gp_Lin
        :rtype: None

        * Projection of the circle <C> on the cylinder <Cyl>.

        :param Cyl:
        :type Cyl: gp_Cylinder
        :param C:
        :type C: gp_Circ
        :rtype: None

        * Projection of the ellipse <E> on the cylinder <Cyl>.

        :param Cyl:
        :type Cyl: gp_Cylinder
        :param E:
        :type E: gp_Elips
        :rtype: None

        """
        _ProjLib.ProjLib_Cylinder_swiginit(self, _ProjLib.new_ProjLib_Cylinder(*args))

    def Init(self, *args):
        """
        :param Cyl:
        :type Cyl: gp_Cylinder
        :rtype: None

        """
        return _ProjLib.ProjLib_Cylinder_Init(self, *args)


    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Cylinder_Project(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_Cylinder.Init = new_instancemethod(_ProjLib.ProjLib_Cylinder_Init, None, ProjLib_Cylinder)
ProjLib_Cylinder.Project = new_instancemethod(_ProjLib.ProjLib_Cylinder_Project, None, ProjLib_Cylinder)
ProjLib_Cylinder._kill_pointed = new_instancemethod(_ProjLib.ProjLib_Cylinder__kill_pointed, None, ProjLib_Cylinder)
ProjLib_Cylinder_swigregister = _ProjLib.ProjLib_Cylinder_swigregister
ProjLib_Cylinder_swigregister(ProjLib_Cylinder)

class ProjLib_Plane(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Undefined projection.

        :rtype: None

        * Projection on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :rtype: None

        * Projection of the line <L> on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :param L:
        :type L: gp_Lin
        :rtype: None

        * Projection of the circle <C> on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :param C:
        :type C: gp_Circ
        :rtype: None

        * Projection of the ellipse <E> on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :param E:
        :type E: gp_Elips
        :rtype: None

        * Projection of the parabola <P> on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :param P:
        :type P: gp_Parab
        :rtype: None

        * Projection of the hyperbola <H> on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :param H:
        :type H: gp_Hypr
        :rtype: None

        """
        _ProjLib.ProjLib_Plane_swiginit(self, _ProjLib.new_ProjLib_Plane(*args))

    def Init(self, *args):
        """
        :param Pl:
        :type Pl: gp_Pln
        :rtype: None

        """
        return _ProjLib.ProjLib_Plane_Init(self, *args)


    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Plane_Project(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_Plane.Init = new_instancemethod(_ProjLib.ProjLib_Plane_Init, None, ProjLib_Plane)
ProjLib_Plane.Project = new_instancemethod(_ProjLib.ProjLib_Plane_Project, None, ProjLib_Plane)
ProjLib_Plane._kill_pointed = new_instancemethod(_ProjLib.ProjLib_Plane__kill_pointed, None, ProjLib_Plane)
ProjLib_Plane_swigregister = _ProjLib.ProjLib_Plane_swigregister
ProjLib_Plane_swigregister(ProjLib_Plane)

class ProjLib_Sphere(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Undefined projection.

        :rtype: None

        * Projection on the sphere <Sp>.

        :param Sp:
        :type Sp: gp_Sphere
        :rtype: None

        * Projection of the circle <C> on the sphere <Sp>.

        :param Sp:
        :type Sp: gp_Sphere
        :param C:
        :type C: gp_Circ
        :rtype: None

        """
        _ProjLib.ProjLib_Sphere_swiginit(self, _ProjLib.new_ProjLib_Sphere(*args))

    def Init(self, *args):
        """
        :param Sp:
        :type Sp: gp_Sphere
        :rtype: None

        """
        return _ProjLib.ProjLib_Sphere_Init(self, *args)


    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Sphere_Project(self, *args)


    def SetInBounds(self, *args):
        """
        * Set the point of parameter U on C in the natural restrictions of the sphere.

        :param U:
        :type U: float
        :rtype: None

        """
        return _ProjLib.ProjLib_Sphere_SetInBounds(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_Sphere.Init = new_instancemethod(_ProjLib.ProjLib_Sphere_Init, None, ProjLib_Sphere)
ProjLib_Sphere.Project = new_instancemethod(_ProjLib.ProjLib_Sphere_Project, None, ProjLib_Sphere)
ProjLib_Sphere.SetInBounds = new_instancemethod(_ProjLib.ProjLib_Sphere_SetInBounds, None, ProjLib_Sphere)
ProjLib_Sphere._kill_pointed = new_instancemethod(_ProjLib.ProjLib_Sphere__kill_pointed, None, ProjLib_Sphere)
ProjLib_Sphere_swigregister = _ProjLib.ProjLib_Sphere_swigregister
ProjLib_Sphere_swigregister(ProjLib_Sphere)

class ProjLib_Torus(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Undefined projection.

        :rtype: None

        * Projection on the torus <To>.

        :param To:
        :type To: gp_Torus
        :rtype: None

        * Projection of the circle <C> on the torus <To>.

        :param To:
        :type To: gp_Torus
        :param C:
        :type C: gp_Circ
        :rtype: None

        """
        _ProjLib.ProjLib_Torus_swiginit(self, _ProjLib.new_ProjLib_Torus(*args))

    def Init(self, *args):
        """
        :param To:
        :type To: gp_Torus
        :rtype: None

        """
        return _ProjLib.ProjLib_Torus_Init(self, *args)


    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Torus_Project(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


ProjLib_Torus.Init = new_instancemethod(_ProjLib.ProjLib_Torus_Init, None, ProjLib_Torus)
ProjLib_Torus.Project = new_instancemethod(_ProjLib.ProjLib_Torus_Project, None, ProjLib_Torus)
ProjLib_Torus._kill_pointed = new_instancemethod(_ProjLib.ProjLib_Torus__kill_pointed, None, ProjLib_Torus)
ProjLib_Torus_swigregister = _ProjLib.ProjLib_Torus_swigregister
ProjLib_Torus_swigregister(ProjLib_Torus)



