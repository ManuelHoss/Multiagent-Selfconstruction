# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _BOPInt.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BOPInt', [dirname(__file__)])
        except ImportError:
            import _BOPInt
            return _BOPInt
        if fp is not None:
            try:
                _mod = imp.load_module('_BOPInt', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _BOPInt = swig_import_helper()
    del swig_import_helper
else:
    import _BOPInt
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BOPInt.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_BOPInt.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BOPInt.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BOPInt.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BOPInt.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BOPInt.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BOPInt.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BOPInt.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BOPInt.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BOPInt.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BOPInt.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BOPInt.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BOPInt.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BOPInt.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BOPInt.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BOPInt.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BOPInt.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _BOPInt.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.MMgt
import OCC.Standard
import OCC.BOPCol
import OCC.TopoDS
import OCC.TCollection
import OCC.TopLoc
import OCC.gp
import OCC.TopAbs
import OCC.IntTools
import OCC.Geom
import OCC.GeomAbs
import OCC.TColgp
import OCC.TColStd
import OCC.BRepAdaptor
import OCC.Adaptor3d
import OCC.Adaptor2d
import OCC.Geom2d
import OCC.math
import OCC.GeomAdaptor
import OCC.Geom2dAdaptor
import OCC.Bnd
import OCC.IntSurf
import OCC.GeomAPI
import OCC.Quantity
import OCC.Extrema
import OCC.Approx
import OCC.AppCont
import OCC.AppParCurves
import OCC.BRepClass3d
import OCC.IntCurveSurface
import OCC.Intf
import OCC.IntCurvesFace
import OCC.Geom2dHatch
import OCC.IntRes2d
import OCC.HatchGen
import OCC.Geom2dInt
import OCC.IntCurve
class BOPInt_Context(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        :param theAllocator:
        :type theAllocator: BOPCol_BaseAllocator &
        :rtype: None

        """
        _BOPInt.BOPInt_Context_swiginit(self, _BOPInt.new_BOPInt_Context(*args))

    def FClass2d(self, *args):
        """
        * Returns a reference to point classifier for given face

        :param aF:
        :type aF: TopoDS_Face &
        :rtype: IntTools_FClass2d

        """
        return _BOPInt.BOPInt_Context_FClass2d(self, *args)


    def ProjPS(self, *args):
        """
        * Returns a reference to point projector for given face

        :param aF:
        :type aF: TopoDS_Face &
        :rtype: GeomAPI_ProjectPointOnSurf

        """
        return _BOPInt.BOPInt_Context_ProjPS(self, *args)


    def ProjPC(self, *args):
        """
        * Returns a reference to point projector for given edge

        :param aE:
        :type aE: TopoDS_Edge &
        :rtype: GeomAPI_ProjectPointOnCurve

        """
        return _BOPInt.BOPInt_Context_ProjPC(self, *args)


    def ProjPT(self, *args):
        """
        * Returns a reference to point projector for given curve

        :param aC:
        :type aC: Handle_Geom_Curve &
        :rtype: GeomAPI_ProjectPointOnCurve

        """
        return _BOPInt.BOPInt_Context_ProjPT(self, *args)


    def SurfaceData(self, *args):
        """
        * Returns a reference to surface localization data for given face

        :param aF:
        :type aF: TopoDS_Face &
        :rtype: IntTools_SurfaceRangeLocalizeData

        """
        return _BOPInt.BOPInt_Context_SurfaceData(self, *args)


    def SolidClassifier(self, *args):
        """
        * Returns a reference to solid classifier for given solid

        :param aSolid:
        :type aSolid: TopoDS_Solid &
        :rtype: BRepClass3d_SolidClassifier

        """
        return _BOPInt.BOPInt_Context_SolidClassifier(self, *args)


    def Hatcher(self, *args):
        """
        * Returns a reference to 2D hatcher for given face

        :param aF:
        :type aF: TopoDS_Face &
        :rtype: Geom2dHatch_Hatcher

        """
        return _BOPInt.BOPInt_Context_Hatcher(self, *args)


    def ComputePE(self, *args):
        """
        * Computes parameter of the Point theP on the edge aE. Returns zero if the distance between point and edge is less than sum of tolerance value of edge and theTopP, otherwise and for following conditions returns negative value 1. the edge is degenerated (-1) 2. the edge does not contain 3d curve and pcurves (-2) 3. projection algorithm failed (-3)

        :param theP:
        :type theP: gp_Pnt
        :param theTolP:
        :type theTolP: float
        :param theE:
        :type theE: TopoDS_Edge &
        :param theT:
        :type theT: float &
        :rtype: int

        """
        return _BOPInt.BOPInt_Context_ComputePE(self, *args)


    def ComputeVE(self, *args):
        """
        * Computes parameter of the vertex aV on the edge aE. Returns zero if the distance between vertex and edge is less than sum of tolerances, otherwise and for following conditions returns negative value 1. the edge is degenerated (-1) 2. the edge does not contain 3d curve and pcurves (-2) 3. projection algorithm failed (-3) Computes parameter aT of the vertex aV on the edge aE. Returns zero if the distance between vertex and edge is less than sum of tolerances, otherwise and for following conditions returns negative value 1. the edge is degenerated (-1) 2. the edge does not contain 3d curve and pcurves (-2) 3. projection algorithm failed (-3) Output parameters bToUpdateVertex - the flag that indicates whether the vertex tolerance should be modified or not aDist - the value of the distance between the vertex and the edge

        :param aV:
        :type aV: TopoDS_Vertex &
        :param aE:
        :type aE: TopoDS_Edge &
        :param aT:
        :type aT: float &
        :rtype: int

        """
        return _BOPInt.BOPInt_Context_ComputeVE(self, *args)


    def ComputeVF(self, *args):
        """
        * Computes UV parameters of the vertex aV on face aF Returns zero if the distance between vertex and face is less than or equal the sum of tolerances and the projection point lays inside boundaries of the face. For following conditions returns negative value 1. projection algorithm failed (-1) 2. distance is more than sum of tolerances (-2) 3. projection point out or on the boundaries of face (-3)

        :param aV:
        :type aV: TopoDS_Vertex &
        :param aF:
        :type aF: TopoDS_Face &
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: int

        """
        return _BOPInt.BOPInt_Context_ComputeVF(self, *args)


    def StatePointFace(self, *args):
        """
        * Returns the state of the point aP2D relative to face aF

        :param aF:
        :type aF: TopoDS_Face &
        :param aP2D:
        :type aP2D: gp_Pnt2d
        :rtype: TopAbs_State

        """
        return _BOPInt.BOPInt_Context_StatePointFace(self, *args)


    def IsPointInFace(self, *args):
        """
        * Returns true if the point aP2D is inside the boundaries of the face aF, otherwise returns false

        :param aF:
        :type aF: TopoDS_Face &
        :param aP2D:
        :type aP2D: gp_Pnt2d
        :rtype: bool

        """
        return _BOPInt.BOPInt_Context_IsPointInFace(self, *args)


    def IsPointInOnFace(self, *args):
        """
        * Returns true if the point aP2D is inside or on the boundaries of aF

        :param aF:
        :type aF: TopoDS_Face &
        :param aP2D:
        :type aP2D: gp_Pnt2d
        :rtype: bool

        """
        return _BOPInt.BOPInt_Context_IsPointInOnFace(self, *args)


    def IsValidPointForFace(self, *args):
        """
        * Returns true if the distance between point aP3D and face aF is less or equal to tolerance aTol and projection point is inside or on the boundaries of the face aF

        :param aP3D:
        :type aP3D: gp_Pnt
        :param aF:
        :type aF: TopoDS_Face &
        :param aTol:
        :type aTol: float
        :rtype: bool

        """
        return _BOPInt.BOPInt_Context_IsValidPointForFace(self, *args)


    def IsValidPointForFaces(self, *args):
        """
        * Returns true if IsValidPointForFace returns true for both face aF1 and aF2

        :param aP3D:
        :type aP3D: gp_Pnt
        :param aF1:
        :type aF1: TopoDS_Face &
        :param aF2:
        :type aF2: TopoDS_Face &
        :param aTol:
        :type aTol: float
        :rtype: bool

        """
        return _BOPInt.BOPInt_Context_IsValidPointForFaces(self, *args)


    def IsValidBlockForFace(self, *args):
        """
        * Returns true if IsValidPointForFace returns true for some 3d point that lay on the curve aIC bounded by parameters aT1 and aT2

        :param aT1:
        :type aT1: float
        :param aT2:
        :type aT2: float
        :param aIC:
        :type aIC: IntTools_Curve &
        :param aF:
        :type aF: TopoDS_Face &
        :param aTol:
        :type aTol: float
        :rtype: bool

        """
        return _BOPInt.BOPInt_Context_IsValidBlockForFace(self, *args)


    def IsValidBlockForFaces(self, *args):
        """
        * Returns true if IsValidBlockForFace returns true for both faces aF1 and aF2

        :param aT1:
        :type aT1: float
        :param aT2:
        :type aT2: float
        :param aIC:
        :type aIC: IntTools_Curve &
        :param aF1:
        :type aF1: TopoDS_Face &
        :param aF2:
        :type aF2: TopoDS_Face &
        :param aTol:
        :type aTol: float
        :rtype: bool

        """
        return _BOPInt.BOPInt_Context_IsValidBlockForFaces(self, *args)


    def IsVertexOnLine(self, *args):
        """
        * Computes parameter of the vertex aV on the curve aIC. Returns true if the distance between vertex and curve is less than sum of tolerance of aV and aTolC, otherwise or if projection algorithm failed returns false (in this case aT isn't significant)

        :param aV:
        :type aV: TopoDS_Vertex &
        :param aIC:
        :type aIC: IntTools_Curve &
        :param aTolC:
        :type aTolC: float
        :param aT:
        :type aT: float &
        :rtype: bool

        * Computes parameter of the vertex aV on the curve aIC. Returns true if the distance between vertex and curve is less than sum of tolerance of aV and aTolC, otherwise or if projection algorithm failed returns false (in this case aT isn't significant)

        :param aV:
        :type aV: TopoDS_Vertex &
        :param aTolV:
        :type aTolV: float
        :param aIC:
        :type aIC: IntTools_Curve &
        :param aTolC:
        :type aTolC: float
        :param aT:
        :type aT: float &
        :rtype: bool

        """
        return _BOPInt.BOPInt_Context_IsVertexOnLine(self, *args)


    def ProjectPointOnEdge(self, *args):
        """
        * Computes parameter of the point aP on the edge aE. Returns false if projection algorithm failed other wiese returns true.

        :param aP:
        :type aP: gp_Pnt
        :param aE:
        :type aE: TopoDS_Edge &
        :param aT:
        :type aT: float &
        :rtype: bool

        """
        return _BOPInt.BOPInt_Context_ProjectPointOnEdge(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(BOPInt_Context self)"""
        return _BOPInt.BOPInt_Context__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(BOPInt_Context self) -> Handle_BOPInt_Context"""
        return _BOPInt.BOPInt_Context_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


BOPInt_Context.FClass2d = new_instancemethod(_BOPInt.BOPInt_Context_FClass2d, None, BOPInt_Context)
BOPInt_Context.ProjPS = new_instancemethod(_BOPInt.BOPInt_Context_ProjPS, None, BOPInt_Context)
BOPInt_Context.ProjPC = new_instancemethod(_BOPInt.BOPInt_Context_ProjPC, None, BOPInt_Context)
BOPInt_Context.ProjPT = new_instancemethod(_BOPInt.BOPInt_Context_ProjPT, None, BOPInt_Context)
BOPInt_Context.SurfaceData = new_instancemethod(_BOPInt.BOPInt_Context_SurfaceData, None, BOPInt_Context)
BOPInt_Context.SolidClassifier = new_instancemethod(_BOPInt.BOPInt_Context_SolidClassifier, None, BOPInt_Context)
BOPInt_Context.Hatcher = new_instancemethod(_BOPInt.BOPInt_Context_Hatcher, None, BOPInt_Context)
BOPInt_Context.ComputePE = new_instancemethod(_BOPInt.BOPInt_Context_ComputePE, None, BOPInt_Context)
BOPInt_Context.ComputeVE = new_instancemethod(_BOPInt.BOPInt_Context_ComputeVE, None, BOPInt_Context)
BOPInt_Context.ComputeVF = new_instancemethod(_BOPInt.BOPInt_Context_ComputeVF, None, BOPInt_Context)
BOPInt_Context.StatePointFace = new_instancemethod(_BOPInt.BOPInt_Context_StatePointFace, None, BOPInt_Context)
BOPInt_Context.IsPointInFace = new_instancemethod(_BOPInt.BOPInt_Context_IsPointInFace, None, BOPInt_Context)
BOPInt_Context.IsPointInOnFace = new_instancemethod(_BOPInt.BOPInt_Context_IsPointInOnFace, None, BOPInt_Context)
BOPInt_Context.IsValidPointForFace = new_instancemethod(_BOPInt.BOPInt_Context_IsValidPointForFace, None, BOPInt_Context)
BOPInt_Context.IsValidPointForFaces = new_instancemethod(_BOPInt.BOPInt_Context_IsValidPointForFaces, None, BOPInt_Context)
BOPInt_Context.IsValidBlockForFace = new_instancemethod(_BOPInt.BOPInt_Context_IsValidBlockForFace, None, BOPInt_Context)
BOPInt_Context.IsValidBlockForFaces = new_instancemethod(_BOPInt.BOPInt_Context_IsValidBlockForFaces, None, BOPInt_Context)
BOPInt_Context.IsVertexOnLine = new_instancemethod(_BOPInt.BOPInt_Context_IsVertexOnLine, None, BOPInt_Context)
BOPInt_Context.ProjectPointOnEdge = new_instancemethod(_BOPInt.BOPInt_Context_ProjectPointOnEdge, None, BOPInt_Context)
BOPInt_Context._kill_pointed = new_instancemethod(_BOPInt.BOPInt_Context__kill_pointed, None, BOPInt_Context)
BOPInt_Context.GetHandle = new_instancemethod(_BOPInt.BOPInt_Context_GetHandle, None, BOPInt_Context)
BOPInt_Context_swigregister = _BOPInt.BOPInt_Context_swigregister
BOPInt_Context_swigregister(BOPInt_Context)

class Handle_BOPInt_Context(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _BOPInt.Handle_BOPInt_Context_swiginit(self, _BOPInt.new_Handle_BOPInt_Context(*args))
    DownCast = staticmethod(_BOPInt.Handle_BOPInt_Context_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_BOPInt_Context.Nullify = new_instancemethod(_BOPInt.Handle_BOPInt_Context_Nullify, None, Handle_BOPInt_Context)
Handle_BOPInt_Context.IsNull = new_instancemethod(_BOPInt.Handle_BOPInt_Context_IsNull, None, Handle_BOPInt_Context)
Handle_BOPInt_Context.GetObject = new_instancemethod(_BOPInt.Handle_BOPInt_Context_GetObject, None, Handle_BOPInt_Context)
Handle_BOPInt_Context._kill_pointed = new_instancemethod(_BOPInt.Handle_BOPInt_Context__kill_pointed, None, Handle_BOPInt_Context)
Handle_BOPInt_Context_swigregister = _BOPInt.Handle_BOPInt_Context_swigregister
Handle_BOPInt_Context_swigregister(Handle_BOPInt_Context)

def Handle_BOPInt_Context_DownCast(AnObject):
    return _BOPInt.Handle_BOPInt_Context_DownCast(AnObject)
Handle_BOPInt_Context_DownCast = _BOPInt.Handle_BOPInt_Context_DownCast

class BOPInt_ShrunkRange(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _BOPInt.BOPInt_ShrunkRange_swiginit(self, _BOPInt.new_BOPInt_ShrunkRange(*args))

    def SetData(self, *args):
        """
        :param aE:
        :type aE: TopoDS_Edge &
        :param aT1:
        :type aT1: float
        :param aT2:
        :type aT2: float
        :param aV1:
        :type aV1: TopoDS_Vertex &
        :param aV2:
        :type aV2: TopoDS_Vertex &
        :rtype: None

        """
        return _BOPInt.BOPInt_ShrunkRange_SetData(self, *args)


    def SetContext(self, *args):
        """
        :param aCtx:
        :type aCtx: Handle_BOPInt_Context &
        :rtype: None

        """
        return _BOPInt.BOPInt_ShrunkRange_SetContext(self, *args)


    def Context(self, *args):
        """
        :rtype: Handle_BOPInt_Context

        """
        return _BOPInt.BOPInt_ShrunkRange_Context(self, *args)


    def SetShrunkRange(self, *args):
        """
        :param aT1:
        :type aT1: float
        :param aT2:
        :type aT2: float
        :rtype: None

        """
        return _BOPInt.BOPInt_ShrunkRange_SetShrunkRange(self, *args)


    def ShrunkRange(self, *args):
        """
        :param aT1:
        :type aT1: float &
        :param aT2:
        :type aT2: float &
        :rtype: None

        """
        return _BOPInt.BOPInt_ShrunkRange_ShrunkRange(self, *args)


    def BndBox(self, *args):
        """
        :rtype: Bnd_Box

        """
        return _BOPInt.BOPInt_ShrunkRange_BndBox(self, *args)


    def Edge(self, *args):
        """
        :rtype: TopoDS_Edge

        """
        return _BOPInt.BOPInt_ShrunkRange_Edge(self, *args)


    def Perform(self, *args):
        """
        :rtype: None

        """
        return _BOPInt.BOPInt_ShrunkRange_Perform(self, *args)


    def ErrorStatus(self, *args):
        """
        * Returns code of computing shrunk range completion 0 - means successful completion 1 - nothing has been done 2 - initial range is out of edge's range 3 - first boundary of initial range is more than last boundary 4 - projection of first vertex failed 5 - projection of second vertex failed 6 - shrunk range can not be computed shrunk range is setted to initial range

        :rtype: int

        """
        return _BOPInt.BOPInt_ShrunkRange_ErrorStatus(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


BOPInt_ShrunkRange.SetData = new_instancemethod(_BOPInt.BOPInt_ShrunkRange_SetData, None, BOPInt_ShrunkRange)
BOPInt_ShrunkRange.SetContext = new_instancemethod(_BOPInt.BOPInt_ShrunkRange_SetContext, None, BOPInt_ShrunkRange)
BOPInt_ShrunkRange.Context = new_instancemethod(_BOPInt.BOPInt_ShrunkRange_Context, None, BOPInt_ShrunkRange)
BOPInt_ShrunkRange.SetShrunkRange = new_instancemethod(_BOPInt.BOPInt_ShrunkRange_SetShrunkRange, None, BOPInt_ShrunkRange)
BOPInt_ShrunkRange.ShrunkRange = new_instancemethod(_BOPInt.BOPInt_ShrunkRange_ShrunkRange, None, BOPInt_ShrunkRange)
BOPInt_ShrunkRange.BndBox = new_instancemethod(_BOPInt.BOPInt_ShrunkRange_BndBox, None, BOPInt_ShrunkRange)
BOPInt_ShrunkRange.Edge = new_instancemethod(_BOPInt.BOPInt_ShrunkRange_Edge, None, BOPInt_ShrunkRange)
BOPInt_ShrunkRange.Perform = new_instancemethod(_BOPInt.BOPInt_ShrunkRange_Perform, None, BOPInt_ShrunkRange)
BOPInt_ShrunkRange.ErrorStatus = new_instancemethod(_BOPInt.BOPInt_ShrunkRange_ErrorStatus, None, BOPInt_ShrunkRange)
BOPInt_ShrunkRange._kill_pointed = new_instancemethod(_BOPInt.BOPInt_ShrunkRange__kill_pointed, None, BOPInt_ShrunkRange)
BOPInt_ShrunkRange_swigregister = _BOPInt.BOPInt_ShrunkRange_swigregister
BOPInt_ShrunkRange_swigregister(BOPInt_ShrunkRange)

class BOPInt_Tools(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CheckCurve(*args):
        """
        :param theC:
        :type theC: Handle_Geom_Curve &
        :param theTol:
        :type theTol: float
        :param theBox:
        :type theBox: Bnd_Box &
        :rtype: bool

        """
        return _BOPInt.BOPInt_Tools_CheckCurve(*args)

    CheckCurve = staticmethod(CheckCurve)

    def IsOnPave(*args):
        """
        :param theT:
        :type theT: float
        :param theRange:
        :type theRange: IntTools_Range &
        :param theTol:
        :type theTol: float
        :rtype: bool

        """
        return _BOPInt.BOPInt_Tools_IsOnPave(*args)

    IsOnPave = staticmethod(IsOnPave)

    def VertexParameters(*args):
        """
        :param theCP:
        :type theCP: IntTools_CommonPrt &
        :param theT1:
        :type theT1: float &
        :param theT2:
        :type theT2: float &
        :rtype: void

        """
        return _BOPInt.BOPInt_Tools_VertexParameters(*args)

    VertexParameters = staticmethod(VertexParameters)

    def VertexParameter(*args):
        """
        :param theCP:
        :type theCP: IntTools_CommonPrt &
        :param theT:
        :type theT: float &
        :rtype: void

        """
        return _BOPInt.BOPInt_Tools_VertexParameter(*args)

    VertexParameter = staticmethod(VertexParameter)

    def IsOnPave1(*args):
        """
        :param theT:
        :type theT: float
        :param theRange:
        :type theRange: IntTools_Range &
        :param theTol:
        :type theTol: float
        :rtype: bool

        """
        return _BOPInt.BOPInt_Tools_IsOnPave1(*args)

    IsOnPave1 = staticmethod(IsOnPave1)

    def IsInRange(*args):
        """
        * Checks if the range <theR> interfere with the range <theRRef>

        :param theRRef:
        :type theRRef: IntTools_Range &
        :param theR:
        :type theR: IntTools_Range &
        :param theTol:
        :type theTol: float
        :rtype: bool

        """
        return _BOPInt.BOPInt_Tools_IsInRange(*args)

    IsInRange = staticmethod(IsInRange)

    def SegPln(*args):
        """
        :param theLin:
        :type theLin: gp_Lin
        :param theTLin1:
        :type theTLin1: float
        :param theTLin2:
        :type theTLin2: float
        :param theTolLin:
        :type theTolLin: float
        :param thePln:
        :type thePln: gp_Pln
        :param theTolPln:
        :type theTolPln: float
        :param theP:
        :type theP: gp_Pnt
        :param theT:
        :type theT: float &
        :param theTolP:
        :type theTolP: float &
        :param theTmin:
        :type theTmin: float &
        :param theTmax:
        :type theTmax: float &
        :rtype: int

        """
        return _BOPInt.BOPInt_Tools_SegPln(*args)

    SegPln = staticmethod(SegPln)

    def __init__(self):
        _BOPInt.BOPInt_Tools_swiginit(self, _BOPInt.new_BOPInt_Tools())

    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


BOPInt_Tools._kill_pointed = new_instancemethod(_BOPInt.BOPInt_Tools__kill_pointed, None, BOPInt_Tools)
BOPInt_Tools_swigregister = _BOPInt.BOPInt_Tools_swigregister
BOPInt_Tools_swigregister(BOPInt_Tools)

def BOPInt_Tools_CheckCurve(*args):
    """
    :param theC:
    :type theC: Handle_Geom_Curve &
    :param theTol:
    :type theTol: float
    :param theBox:
    :type theBox: Bnd_Box &
    :rtype: bool

    """
    return _BOPInt.BOPInt_Tools_CheckCurve(*args)

def BOPInt_Tools_IsOnPave(*args):
    """
    :param theT:
    :type theT: float
    :param theRange:
    :type theRange: IntTools_Range &
    :param theTol:
    :type theTol: float
    :rtype: bool

    """
    return _BOPInt.BOPInt_Tools_IsOnPave(*args)

def BOPInt_Tools_VertexParameters(*args):
    """
    :param theCP:
    :type theCP: IntTools_CommonPrt &
    :param theT1:
    :type theT1: float &
    :param theT2:
    :type theT2: float &
    :rtype: void

    """
    return _BOPInt.BOPInt_Tools_VertexParameters(*args)

def BOPInt_Tools_VertexParameter(*args):
    """
    :param theCP:
    :type theCP: IntTools_CommonPrt &
    :param theT:
    :type theT: float &
    :rtype: void

    """
    return _BOPInt.BOPInt_Tools_VertexParameter(*args)

def BOPInt_Tools_IsOnPave1(*args):
    """
    :param theT:
    :type theT: float
    :param theRange:
    :type theRange: IntTools_Range &
    :param theTol:
    :type theTol: float
    :rtype: bool

    """
    return _BOPInt.BOPInt_Tools_IsOnPave1(*args)

def BOPInt_Tools_IsInRange(*args):
    """
    * Checks if the range <theR> interfere with the range <theRRef>

    :param theRRef:
    :type theRRef: IntTools_Range &
    :param theR:
    :type theR: IntTools_Range &
    :param theTol:
    :type theTol: float
    :rtype: bool

    """
    return _BOPInt.BOPInt_Tools_IsInRange(*args)

def BOPInt_Tools_SegPln(*args):
    """
    :param theLin:
    :type theLin: gp_Lin
    :param theTLin1:
    :type theTLin1: float
    :param theTLin2:
    :type theTLin2: float
    :param theTolLin:
    :type theTolLin: float
    :param thePln:
    :type thePln: gp_Pln
    :param theTolPln:
    :type theTolPln: float
    :param theP:
    :type theP: gp_Pnt
    :param theT:
    :type theT: float &
    :param theTolP:
    :type theTolP: float &
    :param theTmin:
    :type theTmin: float &
    :param theTmax:
    :type theTmax: float &
    :rtype: int

    """
    return _BOPInt.BOPInt_Tools_SegPln(*args)



