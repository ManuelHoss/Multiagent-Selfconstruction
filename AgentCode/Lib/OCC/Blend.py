# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Blend.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Blend', [dirname(__file__)])
        except ImportError:
            import _Blend
            return _Blend
        if fp is not None:
            try:
                _mod = imp.load_module('_Blend', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Blend = swig_import_helper()
    del swig_import_helper
else:
    import _Blend
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Blend.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_Blend.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Blend.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Blend.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Blend.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Blend.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Blend.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Blend.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Blend.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Blend.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Blend.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Blend.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Blend.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Blend.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Blend.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Blend.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Blend.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _Blend.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.math
import OCC.Standard
import OCC.gp
import OCC.TColStd
import OCC.TCollection
import OCC.MMgt
import OCC.GeomAbs
import OCC.TColgp
import OCC.Adaptor2d
import OCC.Geom2d

_Blend.Blend_NoDecroch_swigconstant(_Blend)
Blend_NoDecroch = _Blend.Blend_NoDecroch

_Blend.Blend_DecrochRst1_swigconstant(_Blend)
Blend_DecrochRst1 = _Blend.Blend_DecrochRst1

_Blend.Blend_DecrochRst2_swigconstant(_Blend)
Blend_DecrochRst2 = _Blend.Blend_DecrochRst2

_Blend.Blend_DecrochBoth_swigconstant(_Blend)
Blend_DecrochBoth = _Blend.Blend_DecrochBoth

_Blend.Blend_StepTooLarge_swigconstant(_Blend)
Blend_StepTooLarge = _Blend.Blend_StepTooLarge

_Blend.Blend_StepTooSmall_swigconstant(_Blend)
Blend_StepTooSmall = _Blend.Blend_StepTooSmall

_Blend.Blend_Backward_swigconstant(_Blend)
Blend_Backward = _Blend.Blend_Backward

_Blend.Blend_SamePoints_swigconstant(_Blend)
Blend_SamePoints = _Blend.Blend_SamePoints

_Blend.Blend_OnRst1_swigconstant(_Blend)
Blend_OnRst1 = _Blend.Blend_OnRst1

_Blend.Blend_OnRst2_swigconstant(_Blend)
Blend_OnRst2 = _Blend.Blend_OnRst2

_Blend.Blend_OnRst12_swigconstant(_Blend)
Blend_OnRst12 = _Blend.Blend_OnRst12

_Blend.Blend_OK_swigconstant(_Blend)
Blend_OK = _Blend.Blend_OK
class Blend_AppFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        * returns the number of variables of the function.

        :rtype: int

        """
        return _Blend.Blend_AppFunction_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _Blend.Blend_AppFunction_NbEquations(self, *args)


    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _Blend.Blend_AppFunction_Value(self, *args)


    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_AppFunction_Derivatives(self, *args)


    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_AppFunction_Values(self, *args)


    def Set(self, *args):
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.

        :param Param:
        :type Param: float
        :rtype: void

        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Blend.Blend_AppFunction_Set(self, *args)


    def GetBounds(self, *args):
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 4 variables. Returns in the vector SupBound the greatest values allowed for each of the 4 variables.

        :param InfBound:
        :type InfBound: math_Vector &
        :param SupBound:
        :type SupBound: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space. The computation is made at the current value of the parameter on the guide line.

        :param Sol:
        :type Sol: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: bool

        """
        return _Blend.Blend_AppFunction_IsSolution(self, *args)


    def GetMinimalDistance(self, *args):
        """
        * Returns the minimal Distance beetween two extremitys of calculed sections.

        :rtype: float

        """
        return _Blend.Blend_AppFunction_GetMinimalDistance(self, *args)


    def Pnt1(self, *args):
        """
        * Returns the point on the first support.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_AppFunction_Pnt1(self, *args)


    def Pnt2(self, *args):
        """
        * Returns the point on the first support.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_AppFunction_Pnt2(self, *args)


    def IsRational(self, *args):
        """
        * Returns if the section is rationnal

        :rtype: bool

        """
        return _Blend.Blend_AppFunction_IsRational(self, *args)


    def GetSectionSize(self, *args):
        """
        * Returns the length of the maximum section

        :rtype: float

        """
        return _Blend.Blend_AppFunction_GetSectionSize(self, *args)


    def GetMinimalWeight(self, *args):
        """
        * Compute the minimal value of weight for each poles of all sections.

        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_GetMinimalWeight(self, *args)


    def NbIntervals(self, *args):
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>

        :param S:
        :type S: GeomAbs_Shape
        :rtype: int

        """
        return _Blend.Blend_AppFunction_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>.  The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals() raises 	OutOfRange from Standard

        :param T:
        :type T: TColStd_Array1OfReal &
        :param S:
        :type S: GeomAbs_Shape
        :rtype: void

        """
        return _Blend.Blend_AppFunction_Intervals(self, *args)


    def GetShape(self, *args):
        """
        :param NbPoles:
        :type NbPoles: int &
        :param NbKnots:
        :type NbKnots: int &
        :param Degree:
        :type Degree: int &
        :param NbPoles2d:
        :type NbPoles2d: int &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_GetShape(self, *args)


    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 4 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: math_Vector &
        :param Tol1D:
        :type Tol1D: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_GetTolerance(self, *args)


    def Knots(self, *args):
        """
        :param TKnots:
        :type TKnots: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_Knots(self, *args)


    def Mults(self, *args):
        """
        :param TMults:
        :type TMults: TColStd_Array1OfInteger &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_Mults(self, *args)


    def Section(self, *args):
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Blend.Blend_AppFunction_Section(self, *args)


    def Resolution(self, *args):
        """
        :param IC2d:
        :type IC2d: int
        :param Tol:
        :type Tol: float
        :param TolU:
        :type TolU: float &
        :param TolV:
        :type TolV: float &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_Resolution(self, *args)


    def Parameter(self, *args):
        """
        * Returns the parameter of the point P. Used to impose the parameters in the approximation.

        :param P:
        :type P: Blend_Point &
        :rtype: float

        """
        return _Blend.Blend_AppFunction_Parameter(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_AppFunction.NbVariables = new_instancemethod(_Blend.Blend_AppFunction_NbVariables, None, Blend_AppFunction)
Blend_AppFunction.NbEquations = new_instancemethod(_Blend.Blend_AppFunction_NbEquations, None, Blend_AppFunction)
Blend_AppFunction.Value = new_instancemethod(_Blend.Blend_AppFunction_Value, None, Blend_AppFunction)
Blend_AppFunction.Derivatives = new_instancemethod(_Blend.Blend_AppFunction_Derivatives, None, Blend_AppFunction)
Blend_AppFunction.Values = new_instancemethod(_Blend.Blend_AppFunction_Values, None, Blend_AppFunction)
Blend_AppFunction.Set = new_instancemethod(_Blend.Blend_AppFunction_Set, None, Blend_AppFunction)
Blend_AppFunction.GetBounds = new_instancemethod(_Blend.Blend_AppFunction_GetBounds, None, Blend_AppFunction)
Blend_AppFunction.IsSolution = new_instancemethod(_Blend.Blend_AppFunction_IsSolution, None, Blend_AppFunction)
Blend_AppFunction.GetMinimalDistance = new_instancemethod(_Blend.Blend_AppFunction_GetMinimalDistance, None, Blend_AppFunction)
Blend_AppFunction.Pnt1 = new_instancemethod(_Blend.Blend_AppFunction_Pnt1, None, Blend_AppFunction)
Blend_AppFunction.Pnt2 = new_instancemethod(_Blend.Blend_AppFunction_Pnt2, None, Blend_AppFunction)
Blend_AppFunction.IsRational = new_instancemethod(_Blend.Blend_AppFunction_IsRational, None, Blend_AppFunction)
Blend_AppFunction.GetSectionSize = new_instancemethod(_Blend.Blend_AppFunction_GetSectionSize, None, Blend_AppFunction)
Blend_AppFunction.GetMinimalWeight = new_instancemethod(_Blend.Blend_AppFunction_GetMinimalWeight, None, Blend_AppFunction)
Blend_AppFunction.NbIntervals = new_instancemethod(_Blend.Blend_AppFunction_NbIntervals, None, Blend_AppFunction)
Blend_AppFunction.Intervals = new_instancemethod(_Blend.Blend_AppFunction_Intervals, None, Blend_AppFunction)
Blend_AppFunction.GetShape = new_instancemethod(_Blend.Blend_AppFunction_GetShape, None, Blend_AppFunction)
Blend_AppFunction.GetTolerance = new_instancemethod(_Blend.Blend_AppFunction_GetTolerance, None, Blend_AppFunction)
Blend_AppFunction.Knots = new_instancemethod(_Blend.Blend_AppFunction_Knots, None, Blend_AppFunction)
Blend_AppFunction.Mults = new_instancemethod(_Blend.Blend_AppFunction_Mults, None, Blend_AppFunction)
Blend_AppFunction.Section = new_instancemethod(_Blend.Blend_AppFunction_Section, None, Blend_AppFunction)
Blend_AppFunction.Resolution = new_instancemethod(_Blend.Blend_AppFunction_Resolution, None, Blend_AppFunction)
Blend_AppFunction.Parameter = new_instancemethod(_Blend.Blend_AppFunction_Parameter, None, Blend_AppFunction)
Blend_AppFunction._kill_pointed = new_instancemethod(_Blend.Blend_AppFunction__kill_pointed, None, Blend_AppFunction)
Blend_AppFunction_swigregister = _Blend.Blend_AppFunction_swigregister
Blend_AppFunction_swigregister(Blend_AppFunction)

class Blend_CurvPointFuncInv(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        * Returns 3.

        :rtype: int

        """
        return _Blend.Blend_CurvPointFuncInv_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _Blend.Blend_CurvPointFuncInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _Blend.Blend_CurvPointFuncInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_CurvPointFuncInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_CurvPointFuncInv_Values(self, *args)


    def Set(self, *args):
        """
        * Set the Point on which a solution has to be found.

        :param P:
        :type P: gp_Pnt
        :rtype: void

        """
        return _Blend.Blend_CurvPointFuncInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        """
        return _Blend.Blend_CurvPointFuncInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 3 variables. Returns in the vector SupBound the greatest values allowed for each of the 3 variables.

        :param InfBound:
        :type InfBound: math_Vector &
        :param SupBound:
        :type SupBound: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_CurvPointFuncInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.

        :param Sol:
        :type Sol: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: bool

        """
        return _Blend.Blend_CurvPointFuncInv_IsSolution(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_CurvPointFuncInv.NbVariables = new_instancemethod(_Blend.Blend_CurvPointFuncInv_NbVariables, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.NbEquations = new_instancemethod(_Blend.Blend_CurvPointFuncInv_NbEquations, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.Value = new_instancemethod(_Blend.Blend_CurvPointFuncInv_Value, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.Derivatives = new_instancemethod(_Blend.Blend_CurvPointFuncInv_Derivatives, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.Values = new_instancemethod(_Blend.Blend_CurvPointFuncInv_Values, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.Set = new_instancemethod(_Blend.Blend_CurvPointFuncInv_Set, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.GetTolerance = new_instancemethod(_Blend.Blend_CurvPointFuncInv_GetTolerance, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.GetBounds = new_instancemethod(_Blend.Blend_CurvPointFuncInv_GetBounds, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.IsSolution = new_instancemethod(_Blend.Blend_CurvPointFuncInv_IsSolution, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv._kill_pointed = new_instancemethod(_Blend.Blend_CurvPointFuncInv__kill_pointed, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv_swigregister = _Blend.Blend_CurvPointFuncInv_swigregister
Blend_CurvPointFuncInv_swigregister(Blend_CurvPointFuncInv)

class Blend_FuncInv(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        * Returns 4.

        :rtype: int

        """
        return _Blend.Blend_FuncInv_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _Blend.Blend_FuncInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _Blend.Blend_FuncInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_FuncInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_FuncInv_Values(self, *args)


    def Set(self, *args):
        """
        * Sets the CurveOnSurface on which a solution has to be found. If <OnFirst> is set to Standard_True, the curve will be on the first surface, otherwise the curve is on the second one.

        :param OnFirst:
        :type OnFirst: bool
        :param COnSurf:
        :type COnSurf: Handle_Adaptor2d_HCurve2d &
        :rtype: void

        """
        return _Blend.Blend_FuncInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 4 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        """
        return _Blend.Blend_FuncInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 4 variables. Returns in the vector SupBound the greatest values allowed for each of the 4 variables.

        :param InfBound:
        :type InfBound: math_Vector &
        :param SupBound:
        :type SupBound: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_FuncInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.

        :param Sol:
        :type Sol: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: bool

        """
        return _Blend.Blend_FuncInv_IsSolution(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_FuncInv.NbVariables = new_instancemethod(_Blend.Blend_FuncInv_NbVariables, None, Blend_FuncInv)
Blend_FuncInv.NbEquations = new_instancemethod(_Blend.Blend_FuncInv_NbEquations, None, Blend_FuncInv)
Blend_FuncInv.Value = new_instancemethod(_Blend.Blend_FuncInv_Value, None, Blend_FuncInv)
Blend_FuncInv.Derivatives = new_instancemethod(_Blend.Blend_FuncInv_Derivatives, None, Blend_FuncInv)
Blend_FuncInv.Values = new_instancemethod(_Blend.Blend_FuncInv_Values, None, Blend_FuncInv)
Blend_FuncInv.Set = new_instancemethod(_Blend.Blend_FuncInv_Set, None, Blend_FuncInv)
Blend_FuncInv.GetTolerance = new_instancemethod(_Blend.Blend_FuncInv_GetTolerance, None, Blend_FuncInv)
Blend_FuncInv.GetBounds = new_instancemethod(_Blend.Blend_FuncInv_GetBounds, None, Blend_FuncInv)
Blend_FuncInv.IsSolution = new_instancemethod(_Blend.Blend_FuncInv_IsSolution, None, Blend_FuncInv)
Blend_FuncInv._kill_pointed = new_instancemethod(_Blend.Blend_FuncInv__kill_pointed, None, Blend_FuncInv)
Blend_FuncInv_swigregister = _Blend.Blend_FuncInv_swigregister
Blend_FuncInv_swigregister(Blend_FuncInv)

class Blend_Point(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        * Creates a point on 2 surfaces, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Creates a point on 2 surfaces, without tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :rtype: None

        * Creates a point on a surface and a curve, with tangents.

        :param Pts:
        :type Pts: gp_Pnt
        :param Ptc:
        :type Ptc: gp_Pnt
        :param Param:
        :type Param: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param W:
        :type W: float
        :param Tgs:
        :type Tgs: gp_Vec
        :param Tgc:
        :type Tgc: gp_Vec
        :param Tg2d:
        :type Tg2d: gp_Vec2d
        :rtype: None

        * Creates a point on a surface and a curve, without tangents.

        :param Pts:
        :type Pts: gp_Pnt
        :param Ptc:
        :type Ptc: gp_Pnt
        :param Param:
        :type Param: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param W:
        :type W: float
        :rtype: None

        * Creates a point on a surface and a curve on surface, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC:
        :type PC: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Creates a point on a surface and a curve on surface, without tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC:
        :type PC: float
        :rtype: None

        * Creates a point on two curves on surfaces, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC1:
        :type PC1: float
        :param PC2:
        :type PC2: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Creates a point on two curves on surfaces, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC1:
        :type PC1: float
        :param PC2:
        :type PC2: float
        :rtype: None

        """
        _Blend.Blend_Point_swiginit(self, _Blend.new_Blend_Point(*args))

    def SetValue(self, *args):
        """
        * Set the values for a point on 2 surfaces, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Set the values for a point on 2 surfaces, without tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :rtype: None

        * Set the values for a point on a surface and a curve, with tangents.

        :param Pts:
        :type Pts: gp_Pnt
        :param Ptc:
        :type Ptc: gp_Pnt
        :param Param:
        :type Param: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param W:
        :type W: float
        :param Tgs:
        :type Tgs: gp_Vec
        :param Tgc:
        :type Tgc: gp_Vec
        :param Tg2d:
        :type Tg2d: gp_Vec2d
        :rtype: None

        * Set the values for a point on a surface and a curve, without tangents.

        :param Pts:
        :type Pts: gp_Pnt
        :param Ptc:
        :type Ptc: gp_Pnt
        :param Param:
        :type Param: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param W:
        :type W: float
        :rtype: None

        * Creates a point on a surface and a curve on surface, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC:
        :type PC: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Creates a point on a surface and a curve on surface, without tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC:
        :type PC: float
        :rtype: None

        * Creates a point on two curves on surfaces, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC1:
        :type PC1: float
        :param PC2:
        :type PC2: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Creates a point on two curves on surfaces, without tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC1:
        :type PC1: float
        :param PC2:
        :type PC2: float
        :rtype: None

        * Creates a point on two curves.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param PC1:
        :type PC1: float
        :param PC2:
        :type PC2: float
        :rtype: None

        """
        return _Blend.Blend_Point_SetValue(self, *args)


    def Parameter(self, *args):
        """
        :rtype: float

        """
        return _Blend.Blend_Point_Parameter(self, *args)


    def IsTangencyPoint(self, *args):
        """
        * Returns Standard_True if it was not possible to compute the tangent vectors at PointOnS1 and/or PointOnS2.

        :rtype: bool

        """
        return _Blend.Blend_Point_IsTangencyPoint(self, *args)


    def PointOnS1(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnS1(self, *args)


    def PointOnS2(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnS2(self, *args)


    def ParametersOnS1(self, *args):
        """
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: None

        """
        return _Blend.Blend_Point_ParametersOnS1(self, *args)


    def ParametersOnS2(self, *args):
        """
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: None

        """
        return _Blend.Blend_Point_ParametersOnS2(self, *args)


    def TangentOnS1(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnS1(self, *args)


    def TangentOnS2(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnS2(self, *args)


    def Tangent2dOnS1(self, *args):
        """
        :rtype: gp_Vec2d

        """
        return _Blend.Blend_Point_Tangent2dOnS1(self, *args)


    def Tangent2dOnS2(self, *args):
        """
        :rtype: gp_Vec2d

        """
        return _Blend.Blend_Point_Tangent2dOnS2(self, *args)


    def PointOnS(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnS(self, *args)


    def PointOnC(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnC(self, *args)


    def ParametersOnS(self, *args):
        """
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: None

        """
        return _Blend.Blend_Point_ParametersOnS(self, *args)


    def ParameterOnC(self, *args):
        """
        :rtype: float

        """
        return _Blend.Blend_Point_ParameterOnC(self, *args)


    def TangentOnS(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnS(self, *args)


    def TangentOnC(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnC(self, *args)


    def Tangent2d(self, *args):
        """
        :rtype: gp_Vec2d

        """
        return _Blend.Blend_Point_Tangent2d(self, *args)


    def PointOnC1(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnC1(self, *args)


    def PointOnC2(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnC2(self, *args)


    def ParameterOnC1(self, *args):
        """
        :rtype: float

        """
        return _Blend.Blend_Point_ParameterOnC1(self, *args)


    def ParameterOnC2(self, *args):
        """
        :rtype: float

        """
        return _Blend.Blend_Point_ParameterOnC2(self, *args)


    def TangentOnC1(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnC1(self, *args)


    def TangentOnC2(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnC2(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_Point.SetValue = new_instancemethod(_Blend.Blend_Point_SetValue, None, Blend_Point)
Blend_Point.Parameter = new_instancemethod(_Blend.Blend_Point_Parameter, None, Blend_Point)
Blend_Point.IsTangencyPoint = new_instancemethod(_Blend.Blend_Point_IsTangencyPoint, None, Blend_Point)
Blend_Point.PointOnS1 = new_instancemethod(_Blend.Blend_Point_PointOnS1, None, Blend_Point)
Blend_Point.PointOnS2 = new_instancemethod(_Blend.Blend_Point_PointOnS2, None, Blend_Point)
Blend_Point.ParametersOnS1 = new_instancemethod(_Blend.Blend_Point_ParametersOnS1, None, Blend_Point)
Blend_Point.ParametersOnS2 = new_instancemethod(_Blend.Blend_Point_ParametersOnS2, None, Blend_Point)
Blend_Point.TangentOnS1 = new_instancemethod(_Blend.Blend_Point_TangentOnS1, None, Blend_Point)
Blend_Point.TangentOnS2 = new_instancemethod(_Blend.Blend_Point_TangentOnS2, None, Blend_Point)
Blend_Point.Tangent2dOnS1 = new_instancemethod(_Blend.Blend_Point_Tangent2dOnS1, None, Blend_Point)
Blend_Point.Tangent2dOnS2 = new_instancemethod(_Blend.Blend_Point_Tangent2dOnS2, None, Blend_Point)
Blend_Point.PointOnS = new_instancemethod(_Blend.Blend_Point_PointOnS, None, Blend_Point)
Blend_Point.PointOnC = new_instancemethod(_Blend.Blend_Point_PointOnC, None, Blend_Point)
Blend_Point.ParametersOnS = new_instancemethod(_Blend.Blend_Point_ParametersOnS, None, Blend_Point)
Blend_Point.ParameterOnC = new_instancemethod(_Blend.Blend_Point_ParameterOnC, None, Blend_Point)
Blend_Point.TangentOnS = new_instancemethod(_Blend.Blend_Point_TangentOnS, None, Blend_Point)
Blend_Point.TangentOnC = new_instancemethod(_Blend.Blend_Point_TangentOnC, None, Blend_Point)
Blend_Point.Tangent2d = new_instancemethod(_Blend.Blend_Point_Tangent2d, None, Blend_Point)
Blend_Point.PointOnC1 = new_instancemethod(_Blend.Blend_Point_PointOnC1, None, Blend_Point)
Blend_Point.PointOnC2 = new_instancemethod(_Blend.Blend_Point_PointOnC2, None, Blend_Point)
Blend_Point.ParameterOnC1 = new_instancemethod(_Blend.Blend_Point_ParameterOnC1, None, Blend_Point)
Blend_Point.ParameterOnC2 = new_instancemethod(_Blend.Blend_Point_ParameterOnC2, None, Blend_Point)
Blend_Point.TangentOnC1 = new_instancemethod(_Blend.Blend_Point_TangentOnC1, None, Blend_Point)
Blend_Point.TangentOnC2 = new_instancemethod(_Blend.Blend_Point_TangentOnC2, None, Blend_Point)
Blend_Point._kill_pointed = new_instancemethod(_Blend.Blend_Point__kill_pointed, None, Blend_Point)
Blend_Point_swigregister = _Blend.Blend_Point_swigregister
Blend_Point_swigregister(Blend_Point)

class Blend_SequenceNodeOfSequenceOfPoint(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: Blend_Point &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _Blend.Blend_SequenceNodeOfSequenceOfPoint_swiginit(self, _Blend.new_Blend_SequenceNodeOfSequenceOfPoint(*args))

    def Value(self, *args):
        """
        :rtype: Blend_Point

        """
        return _Blend.Blend_SequenceNodeOfSequenceOfPoint_Value(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(Blend_SequenceNodeOfSequenceOfPoint self)"""
        return _Blend.Blend_SequenceNodeOfSequenceOfPoint__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(Blend_SequenceNodeOfSequenceOfPoint self) -> Handle_Blend_SequenceNodeOfSequenceOfPoint"""
        return _Blend.Blend_SequenceNodeOfSequenceOfPoint_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_SequenceNodeOfSequenceOfPoint.Value = new_instancemethod(_Blend.Blend_SequenceNodeOfSequenceOfPoint_Value, None, Blend_SequenceNodeOfSequenceOfPoint)
Blend_SequenceNodeOfSequenceOfPoint._kill_pointed = new_instancemethod(_Blend.Blend_SequenceNodeOfSequenceOfPoint__kill_pointed, None, Blend_SequenceNodeOfSequenceOfPoint)
Blend_SequenceNodeOfSequenceOfPoint.GetHandle = new_instancemethod(_Blend.Blend_SequenceNodeOfSequenceOfPoint_GetHandle, None, Blend_SequenceNodeOfSequenceOfPoint)
Blend_SequenceNodeOfSequenceOfPoint_swigregister = _Blend.Blend_SequenceNodeOfSequenceOfPoint_swigregister
Blend_SequenceNodeOfSequenceOfPoint_swigregister(Blend_SequenceNodeOfSequenceOfPoint)

class Handle_Blend_SequenceNodeOfSequenceOfPoint(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_swiginit(self, _Blend.new_Handle_Blend_SequenceNodeOfSequenceOfPoint(*args))
    DownCast = staticmethod(_Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_Blend_SequenceNodeOfSequenceOfPoint.Nullify = new_instancemethod(_Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_Nullify, None, Handle_Blend_SequenceNodeOfSequenceOfPoint)
Handle_Blend_SequenceNodeOfSequenceOfPoint.IsNull = new_instancemethod(_Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_IsNull, None, Handle_Blend_SequenceNodeOfSequenceOfPoint)
Handle_Blend_SequenceNodeOfSequenceOfPoint.GetObject = new_instancemethod(_Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_GetObject, None, Handle_Blend_SequenceNodeOfSequenceOfPoint)
Handle_Blend_SequenceNodeOfSequenceOfPoint._kill_pointed = new_instancemethod(_Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint__kill_pointed, None, Handle_Blend_SequenceNodeOfSequenceOfPoint)
Handle_Blend_SequenceNodeOfSequenceOfPoint_swigregister = _Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_swigregister
Handle_Blend_SequenceNodeOfSequenceOfPoint_swigregister(Handle_Blend_SequenceNodeOfSequenceOfPoint)

def Handle_Blend_SequenceNodeOfSequenceOfPoint_DownCast(AnObject):
    return _Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_DownCast(AnObject)
Handle_Blend_SequenceNodeOfSequenceOfPoint_DownCast = _Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_DownCast

class Blend_SequenceOfPoint(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _Blend.Blend_SequenceOfPoint_swiginit(self, _Blend.new_Blend_SequenceOfPoint(*args))

    def Clear(self, *args):
        """
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_Clear(self, *args)


    def Assign(self, *args):
        """
        :param Other:
        :type Other: Blend_SequenceOfPoint &
        :rtype: Blend_SequenceOfPoint

        """
        return _Blend.Blend_SequenceOfPoint_Assign(self, *args)


    def Set(self, *args):
        """
        :param Other:
        :type Other: Blend_SequenceOfPoint &
        :rtype: Blend_SequenceOfPoint

        """
        return _Blend.Blend_SequenceOfPoint_Set(self, *args)


    def Append(self, *args):
        """
        :param T:
        :type T: Blend_Point &
        :rtype: None

        :param S:
        :type S: Blend_SequenceOfPoint &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_Append(self, *args)


    def Prepend(self, *args):
        """
        :param T:
        :type T: Blend_Point &
        :rtype: None

        :param S:
        :type S: Blend_SequenceOfPoint &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Blend_Point &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Blend_SequenceOfPoint &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Blend_Point &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Blend_SequenceOfPoint &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_InsertAfter(self, *args)


    def First(self, *args):
        """
        :rtype: Blend_Point

        """
        return _Blend.Blend_SequenceOfPoint_First(self, *args)


    def Last(self, *args):
        """
        :rtype: Blend_Point

        """
        return _Blend.Blend_SequenceOfPoint_Last(self, *args)


    def Split(self, *args):
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: Blend_SequenceOfPoint &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_Split(self, *args)


    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Blend_Point

        """
        return _Blend.Blend_SequenceOfPoint_Value(self, *args)


    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Blend_Point &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_SetValue(self, *args)


    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Blend_Point

        """
        return _Blend.Blend_SequenceOfPoint_ChangeValue(self, *args)


    def Remove(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_Remove(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_SequenceOfPoint.Clear = new_instancemethod(_Blend.Blend_SequenceOfPoint_Clear, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Assign = new_instancemethod(_Blend.Blend_SequenceOfPoint_Assign, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Set = new_instancemethod(_Blend.Blend_SequenceOfPoint_Set, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Append = new_instancemethod(_Blend.Blend_SequenceOfPoint_Append, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Prepend = new_instancemethod(_Blend.Blend_SequenceOfPoint_Prepend, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.InsertBefore = new_instancemethod(_Blend.Blend_SequenceOfPoint_InsertBefore, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.InsertAfter = new_instancemethod(_Blend.Blend_SequenceOfPoint_InsertAfter, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.First = new_instancemethod(_Blend.Blend_SequenceOfPoint_First, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Last = new_instancemethod(_Blend.Blend_SequenceOfPoint_Last, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Split = new_instancemethod(_Blend.Blend_SequenceOfPoint_Split, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Value = new_instancemethod(_Blend.Blend_SequenceOfPoint_Value, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.SetValue = new_instancemethod(_Blend.Blend_SequenceOfPoint_SetValue, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.ChangeValue = new_instancemethod(_Blend.Blend_SequenceOfPoint_ChangeValue, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Remove = new_instancemethod(_Blend.Blend_SequenceOfPoint_Remove, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint._kill_pointed = new_instancemethod(_Blend.Blend_SequenceOfPoint__kill_pointed, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint_swigregister = _Blend.Blend_SequenceOfPoint_swigregister
Blend_SequenceOfPoint_swigregister(Blend_SequenceOfPoint)

class Blend_SurfCurvFuncInv(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        * Returns 3.

        :rtype: int

        """
        return _Blend.Blend_SurfCurvFuncInv_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _Blend.Blend_SurfCurvFuncInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _Blend.Blend_SurfCurvFuncInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_SurfCurvFuncInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_SurfCurvFuncInv_Values(self, *args)


    def Set(self, *args):
        """
        * Set the Point on which a solution has to be found.

        :param Rst:
        :type Rst: Handle_Adaptor2d_HCurve2d &
        :rtype: void

        """
        return _Blend.Blend_SurfCurvFuncInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        """
        return _Blend.Blend_SurfCurvFuncInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 3 variables. Returns in the vector SupBound the greatest values allowed for each of the 3 variables.

        :param InfBound:
        :type InfBound: math_Vector &
        :param SupBound:
        :type SupBound: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_SurfCurvFuncInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.

        :param Sol:
        :type Sol: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: bool

        """
        return _Blend.Blend_SurfCurvFuncInv_IsSolution(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_SurfCurvFuncInv.NbVariables = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_NbVariables, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.NbEquations = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_NbEquations, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.Value = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_Value, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.Derivatives = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_Derivatives, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.Values = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_Values, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.Set = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_Set, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.GetTolerance = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_GetTolerance, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.GetBounds = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_GetBounds, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.IsSolution = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_IsSolution, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv._kill_pointed = new_instancemethod(_Blend.Blend_SurfCurvFuncInv__kill_pointed, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv_swigregister = _Blend.Blend_SurfCurvFuncInv_swigregister
Blend_SurfCurvFuncInv_swigregister(Blend_SurfCurvFuncInv)

class Blend_SurfPointFuncInv(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        * Returns 3.

        :rtype: int

        """
        return _Blend.Blend_SurfPointFuncInv_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _Blend.Blend_SurfPointFuncInv_NbEquations(self, *args)


    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _Blend.Blend_SurfPointFuncInv_Value(self, *args)


    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_SurfPointFuncInv_Derivatives(self, *args)


    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_SurfPointFuncInv_Values(self, *args)


    def Set(self, *args):
        """
        * Set the Point on which a solution has to be found.

        :param P:
        :type P: gp_Pnt
        :rtype: void

        """
        return _Blend.Blend_SurfPointFuncInv_Set(self, *args)


    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        """
        return _Blend.Blend_SurfPointFuncInv_GetTolerance(self, *args)


    def GetBounds(self, *args):
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 3 variables. Returns in the vector SupBound the greatest values allowed for each of the 3 variables.

        :param InfBound:
        :type InfBound: math_Vector &
        :param SupBound:
        :type SupBound: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_SurfPointFuncInv_GetBounds(self, *args)


    def IsSolution(self, *args):
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.

        :param Sol:
        :type Sol: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: bool

        """
        return _Blend.Blend_SurfPointFuncInv_IsSolution(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_SurfPointFuncInv.NbVariables = new_instancemethod(_Blend.Blend_SurfPointFuncInv_NbVariables, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.NbEquations = new_instancemethod(_Blend.Blend_SurfPointFuncInv_NbEquations, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.Value = new_instancemethod(_Blend.Blend_SurfPointFuncInv_Value, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.Derivatives = new_instancemethod(_Blend.Blend_SurfPointFuncInv_Derivatives, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.Values = new_instancemethod(_Blend.Blend_SurfPointFuncInv_Values, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.Set = new_instancemethod(_Blend.Blend_SurfPointFuncInv_Set, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.GetTolerance = new_instancemethod(_Blend.Blend_SurfPointFuncInv_GetTolerance, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.GetBounds = new_instancemethod(_Blend.Blend_SurfPointFuncInv_GetBounds, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.IsSolution = new_instancemethod(_Blend.Blend_SurfPointFuncInv_IsSolution, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv._kill_pointed = new_instancemethod(_Blend.Blend_SurfPointFuncInv__kill_pointed, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv_swigregister = _Blend.Blend_SurfPointFuncInv_swigregister
Blend_SurfPointFuncInv_swigregister(Blend_SurfPointFuncInv)

class Blend_CSFunction(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Set(self, *args):
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.

        :param Param:
        :type Param: float
        :rtype: void

        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Blend.Blend_CSFunction_Set(self, *args)


    def PointOnS(self, *args):
        """
        * Returns the point on the surface.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_CSFunction_PointOnS(self, *args)


    def PointOnC(self, *args):
        """
        * Returns the point on the curve.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_CSFunction_PointOnC(self, *args)


    def Pnt2d(self, *args):
        """
        * Returns U,V coordinates of the point on the surface.

        :rtype: gp_Pnt2d

        """
        return _Blend.Blend_CSFunction_Pnt2d(self, *args)


    def ParameterOnC(self, *args):
        """
        * Returns parameter of the point on the curve.

        :rtype: float

        """
        return _Blend.Blend_CSFunction_ParameterOnC(self, *args)


    def IsTangencyPoint(self, *args):
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS and/or PointOnC.

        :rtype: bool

        """
        return _Blend.Blend_CSFunction_IsTangencyPoint(self, *args)


    def TangentOnS(self, *args):
        """
        * Returns the tangent vector at PointOnS, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_CSFunction_TangentOnS(self, *args)


    def Tangent2d(self, *args):
        """
        * Returns the tangent vector at PointOnS, in the parametric space of the first surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_CSFunction_Tangent2d(self, *args)


    def TangentOnC(self, *args):
        """
        * Returns the tangent vector at PointOnC, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_CSFunction_TangentOnC(self, *args)


    def Tangent(self, *args):
        """
        * Returns the tangent vector at the section, at the beginning and the end of the section, and returns the normal (of the surfaces) at these points.

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param TgS:
        :type TgS: gp_Vec
        :param NormS:
        :type NormS: gp_Vec
        :rtype: void

        """
        return _Blend.Blend_CSFunction_Tangent(self, *args)


    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: math_Vector &
        :param Tol1D:
        :type Tol1D: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_CSFunction_GetTolerance(self, *args)


    def Section(self, *args):
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Blend.Blend_CSFunction_Section(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_CSFunction.Set = new_instancemethod(_Blend.Blend_CSFunction_Set, None, Blend_CSFunction)
Blend_CSFunction.PointOnS = new_instancemethod(_Blend.Blend_CSFunction_PointOnS, None, Blend_CSFunction)
Blend_CSFunction.PointOnC = new_instancemethod(_Blend.Blend_CSFunction_PointOnC, None, Blend_CSFunction)
Blend_CSFunction.Pnt2d = new_instancemethod(_Blend.Blend_CSFunction_Pnt2d, None, Blend_CSFunction)
Blend_CSFunction.ParameterOnC = new_instancemethod(_Blend.Blend_CSFunction_ParameterOnC, None, Blend_CSFunction)
Blend_CSFunction.IsTangencyPoint = new_instancemethod(_Blend.Blend_CSFunction_IsTangencyPoint, None, Blend_CSFunction)
Blend_CSFunction.TangentOnS = new_instancemethod(_Blend.Blend_CSFunction_TangentOnS, None, Blend_CSFunction)
Blend_CSFunction.Tangent2d = new_instancemethod(_Blend.Blend_CSFunction_Tangent2d, None, Blend_CSFunction)
Blend_CSFunction.TangentOnC = new_instancemethod(_Blend.Blend_CSFunction_TangentOnC, None, Blend_CSFunction)
Blend_CSFunction.Tangent = new_instancemethod(_Blend.Blend_CSFunction_Tangent, None, Blend_CSFunction)
Blend_CSFunction.GetTolerance = new_instancemethod(_Blend.Blend_CSFunction_GetTolerance, None, Blend_CSFunction)
Blend_CSFunction.Section = new_instancemethod(_Blend.Blend_CSFunction_Section, None, Blend_CSFunction)
Blend_CSFunction._kill_pointed = new_instancemethod(_Blend.Blend_CSFunction__kill_pointed, None, Blend_CSFunction)
Blend_CSFunction_swigregister = _Blend.Blend_CSFunction_swigregister
Blend_CSFunction_swigregister(Blend_CSFunction)

class Blend_Function(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Set(self, *args):
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.

        :param Param:
        :type Param: float
        :rtype: void

        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Blend.Blend_Function_Set(self, *args)


    def PointOnS1(self, *args):
        """
        * Returns the point on the first surface, at parameter Sol(1),Sol(2) (Sol is the vector used in the call of IsSolution.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_Function_PointOnS1(self, *args)


    def PointOnS2(self, *args):
        """
        * Returns the point on the second surface, at parameter Sol(3),Sol(4) (Sol is the vector used in the call of IsSolution.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_Function_PointOnS2(self, *args)


    def IsTangencyPoint(self, *args):
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS1 and/or PointOnS2.

        :rtype: bool

        """
        return _Blend.Blend_Function_IsTangencyPoint(self, *args)


    def TangentOnS1(self, *args):
        """
        * Returns the tangent vector at PointOnS1, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_Function_TangentOnS1(self, *args)


    def Tangent2dOnS1(self, *args):
        """
        * Returns the tangent vector at PointOnS1, in the parametric space of the first surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_Function_Tangent2dOnS1(self, *args)


    def TangentOnS2(self, *args):
        """
        * Returns the tangent vector at PointOnS2, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_Function_TangentOnS2(self, *args)


    def Tangent2dOnS2(self, *args):
        """
        * Returns the tangent vector at PointOnS2, in the parametric space of the second surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_Function_Tangent2dOnS2(self, *args)


    def Tangent(self, *args):
        """
        * Returns the tangent vector at the section, at the beginning and the end of the section, and returns the normal (of the surfaces) at these points.

        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param TgFirst:
        :type TgFirst: gp_Vec
        :param TgLast:
        :type TgLast: gp_Vec
        :param NormFirst:
        :type NormFirst: gp_Vec
        :param NormLast:
        :type NormLast: gp_Vec
        :rtype: void

        """
        return _Blend.Blend_Function_Tangent(self, *args)


    def TwistOnS1(self, *args):
        """
        :rtype: bool

        """
        return _Blend.Blend_Function_TwistOnS1(self, *args)


    def TwistOnS2(self, *args):
        """
        :rtype: bool

        """
        return _Blend.Blend_Function_TwistOnS2(self, *args)


    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 4 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: math_Vector &
        :param Tol1D:
        :type Tol1D: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_Function_GetTolerance(self, *args)


    def Section(self, *args):
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Blend.Blend_Function_Section(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_Function.Set = new_instancemethod(_Blend.Blend_Function_Set, None, Blend_Function)
Blend_Function.PointOnS1 = new_instancemethod(_Blend.Blend_Function_PointOnS1, None, Blend_Function)
Blend_Function.PointOnS2 = new_instancemethod(_Blend.Blend_Function_PointOnS2, None, Blend_Function)
Blend_Function.IsTangencyPoint = new_instancemethod(_Blend.Blend_Function_IsTangencyPoint, None, Blend_Function)
Blend_Function.TangentOnS1 = new_instancemethod(_Blend.Blend_Function_TangentOnS1, None, Blend_Function)
Blend_Function.Tangent2dOnS1 = new_instancemethod(_Blend.Blend_Function_Tangent2dOnS1, None, Blend_Function)
Blend_Function.TangentOnS2 = new_instancemethod(_Blend.Blend_Function_TangentOnS2, None, Blend_Function)
Blend_Function.Tangent2dOnS2 = new_instancemethod(_Blend.Blend_Function_Tangent2dOnS2, None, Blend_Function)
Blend_Function.Tangent = new_instancemethod(_Blend.Blend_Function_Tangent, None, Blend_Function)
Blend_Function.TwistOnS1 = new_instancemethod(_Blend.Blend_Function_TwistOnS1, None, Blend_Function)
Blend_Function.TwistOnS2 = new_instancemethod(_Blend.Blend_Function_TwistOnS2, None, Blend_Function)
Blend_Function.GetTolerance = new_instancemethod(_Blend.Blend_Function_GetTolerance, None, Blend_Function)
Blend_Function.Section = new_instancemethod(_Blend.Blend_Function_Section, None, Blend_Function)
Blend_Function._kill_pointed = new_instancemethod(_Blend.Blend_Function__kill_pointed, None, Blend_Function)
Blend_Function_swigregister = _Blend.Blend_Function_swigregister
Blend_Function_swigregister(Blend_Function)

class Blend_RstRstFunction(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Set(self, *args):
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.

        :param Param:
        :type Param: float
        :rtype: void

        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Blend.Blend_RstRstFunction_Set(self, *args)


    def PointOnRst1(self, *args):
        """
        * Returns the point on the surface.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_RstRstFunction_PointOnRst1(self, *args)


    def PointOnRst2(self, *args):
        """
        * Returns the point on the curve.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_RstRstFunction_PointOnRst2(self, *args)


    def Pnt2dOnRst1(self, *args):
        """
        * Returns U,V coordinates of the point on the surface.

        :rtype: gp_Pnt2d

        """
        return _Blend.Blend_RstRstFunction_Pnt2dOnRst1(self, *args)


    def Pnt2dOnRst2(self, *args):
        """
        * Returns U,V coordinates of the point on the curve on surface.

        :rtype: gp_Pnt2d

        """
        return _Blend.Blend_RstRstFunction_Pnt2dOnRst2(self, *args)


    def ParameterOnRst1(self, *args):
        """
        * Returns parameter of the point on the curve.

        :rtype: float

        """
        return _Blend.Blend_RstRstFunction_ParameterOnRst1(self, *args)


    def ParameterOnRst2(self, *args):
        """
        * Returns parameter of the point on the curve.

        :rtype: float

        """
        return _Blend.Blend_RstRstFunction_ParameterOnRst2(self, *args)


    def IsTangencyPoint(self, *args):
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS and/or PointOnRst.

        :rtype: bool

        """
        return _Blend.Blend_RstRstFunction_IsTangencyPoint(self, *args)


    def TangentOnRst1(self, *args):
        """
        * Returns the tangent vector at PointOnS, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_RstRstFunction_TangentOnRst1(self, *args)


    def Tangent2dOnRst1(self, *args):
        """
        * Returns the tangent vector at PointOnS, in the parametric space of the first surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_RstRstFunction_Tangent2dOnRst1(self, *args)


    def TangentOnRst2(self, *args):
        """
        * Returns the tangent vector at PointOnC, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_RstRstFunction_TangentOnRst2(self, *args)


    def Tangent2dOnRst2(self, *args):
        """
        * Returns the tangent vector at PointOnRst, in the parametric space of the second surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_RstRstFunction_Tangent2dOnRst2(self, *args)


    def Decroch(self, *args):
        """
        * Enables to implement a criterion of decrochage specific to the function. Warning: Can be called without previous call of issolution but the values calculated can be senseless.

        :param Sol:
        :type Sol: math_Vector &
        :param NRst1:
        :type NRst1: gp_Vec
        :param TgRst1:
        :type TgRst1: gp_Vec
        :param NRst2:
        :type NRst2: gp_Vec
        :param TgRst2:
        :type TgRst2: gp_Vec
        :rtype: Blend_DecrochStatus

        """
        return _Blend.Blend_RstRstFunction_Decroch(self, *args)


    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each variable; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: math_Vector &
        :param Tol1D:
        :type Tol1D: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_RstRstFunction_GetTolerance(self, *args)


    def Section(self, *args):
        """
        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Blend.Blend_RstRstFunction_Section(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_RstRstFunction.Set = new_instancemethod(_Blend.Blend_RstRstFunction_Set, None, Blend_RstRstFunction)
Blend_RstRstFunction.PointOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_PointOnRst1, None, Blend_RstRstFunction)
Blend_RstRstFunction.PointOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_PointOnRst2, None, Blend_RstRstFunction)
Blend_RstRstFunction.Pnt2dOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_Pnt2dOnRst1, None, Blend_RstRstFunction)
Blend_RstRstFunction.Pnt2dOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_Pnt2dOnRst2, None, Blend_RstRstFunction)
Blend_RstRstFunction.ParameterOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_ParameterOnRst1, None, Blend_RstRstFunction)
Blend_RstRstFunction.ParameterOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_ParameterOnRst2, None, Blend_RstRstFunction)
Blend_RstRstFunction.IsTangencyPoint = new_instancemethod(_Blend.Blend_RstRstFunction_IsTangencyPoint, None, Blend_RstRstFunction)
Blend_RstRstFunction.TangentOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_TangentOnRst1, None, Blend_RstRstFunction)
Blend_RstRstFunction.Tangent2dOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_Tangent2dOnRst1, None, Blend_RstRstFunction)
Blend_RstRstFunction.TangentOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_TangentOnRst2, None, Blend_RstRstFunction)
Blend_RstRstFunction.Tangent2dOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_Tangent2dOnRst2, None, Blend_RstRstFunction)
Blend_RstRstFunction.Decroch = new_instancemethod(_Blend.Blend_RstRstFunction_Decroch, None, Blend_RstRstFunction)
Blend_RstRstFunction.GetTolerance = new_instancemethod(_Blend.Blend_RstRstFunction_GetTolerance, None, Blend_RstRstFunction)
Blend_RstRstFunction.Section = new_instancemethod(_Blend.Blend_RstRstFunction_Section, None, Blend_RstRstFunction)
Blend_RstRstFunction._kill_pointed = new_instancemethod(_Blend.Blend_RstRstFunction__kill_pointed, None, Blend_RstRstFunction)
Blend_RstRstFunction_swigregister = _Blend.Blend_RstRstFunction_swigregister
Blend_RstRstFunction_swigregister(Blend_RstRstFunction)

class Blend_SurfRstFunction(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Set(self, *args):
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.

        :param Param:
        :type Param: float
        :rtype: void

        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Blend.Blend_SurfRstFunction_Set(self, *args)


    def PointOnS(self, *args):
        """
        * Returns the point on the surface.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_SurfRstFunction_PointOnS(self, *args)


    def PointOnRst(self, *args):
        """
        * Returns the point on the curve.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_SurfRstFunction_PointOnRst(self, *args)


    def Pnt2dOnS(self, *args):
        """
        * Returns U,V coordinates of the point on the surface.

        :rtype: gp_Pnt2d

        """
        return _Blend.Blend_SurfRstFunction_Pnt2dOnS(self, *args)


    def Pnt2dOnRst(self, *args):
        """
        * Returns U,V coordinates of the point on the curve on surface.

        :rtype: gp_Pnt2d

        """
        return _Blend.Blend_SurfRstFunction_Pnt2dOnRst(self, *args)


    def ParameterOnRst(self, *args):
        """
        * Returns parameter of the point on the curve.

        :rtype: float

        """
        return _Blend.Blend_SurfRstFunction_ParameterOnRst(self, *args)


    def IsTangencyPoint(self, *args):
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS and/or PointOnRst.

        :rtype: bool

        """
        return _Blend.Blend_SurfRstFunction_IsTangencyPoint(self, *args)


    def TangentOnS(self, *args):
        """
        * Returns the tangent vector at PointOnS, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_SurfRstFunction_TangentOnS(self, *args)


    def Tangent2dOnS(self, *args):
        """
        * Returns the tangent vector at PointOnS, in the parametric space of the first surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_SurfRstFunction_Tangent2dOnS(self, *args)


    def TangentOnRst(self, *args):
        """
        * Returns the tangent vector at PointOnC, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_SurfRstFunction_TangentOnRst(self, *args)


    def Tangent2dOnRst(self, *args):
        """
        * Returns the tangent vector at PointOnRst, in the parametric space of the second surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_SurfRstFunction_Tangent2dOnRst(self, *args)


    def Decroch(self, *args):
        """
        * Enables implementation of a criterion of decrochage specific to the function.

        :param Sol:
        :type Sol: math_Vector &
        :param NS:
        :type NS: gp_Vec
        :param TgS:
        :type TgS: gp_Vec
        :rtype: bool

        """
        return _Blend.Blend_SurfRstFunction_Decroch(self, *args)


    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each variable; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: math_Vector &
        :param Tol1D:
        :type Tol1D: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_SurfRstFunction_GetTolerance(self, *args)


    def Section(self, *args):
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Blend.Blend_SurfRstFunction_Section(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Blend_SurfRstFunction.Set = new_instancemethod(_Blend.Blend_SurfRstFunction_Set, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.PointOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_PointOnS, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.PointOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_PointOnRst, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Pnt2dOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_Pnt2dOnS, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Pnt2dOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_Pnt2dOnRst, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.ParameterOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_ParameterOnRst, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.IsTangencyPoint = new_instancemethod(_Blend.Blend_SurfRstFunction_IsTangencyPoint, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.TangentOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_TangentOnS, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Tangent2dOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_Tangent2dOnS, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.TangentOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_TangentOnRst, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Tangent2dOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_Tangent2dOnRst, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Decroch = new_instancemethod(_Blend.Blend_SurfRstFunction_Decroch, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.GetTolerance = new_instancemethod(_Blend.Blend_SurfRstFunction_GetTolerance, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Section = new_instancemethod(_Blend.Blend_SurfRstFunction_Section, None, Blend_SurfRstFunction)
Blend_SurfRstFunction._kill_pointed = new_instancemethod(_Blend.Blend_SurfRstFunction__kill_pointed, None, Blend_SurfRstFunction)
Blend_SurfRstFunction_swigregister = _Blend.Blend_SurfRstFunction_swigregister
Blend_SurfRstFunction_swigregister(Blend_SurfRstFunction)



