# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Approx.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Approx', [dirname(__file__)])
        except ImportError:
            import _Approx
            return _Approx
        if fp is not None:
            try:
                _mod = imp.load_module('_Approx', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Approx = swig_import_helper()
    del swig_import_helper
else:
    import _Approx
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Approx.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_Approx.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Approx.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Approx.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Approx.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Approx.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Approx.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Approx.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Approx.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Approx.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Approx.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Approx.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Approx.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Approx.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Approx.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Approx.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Approx.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _Approx.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.Standard
import OCC.Adaptor3d
import OCC.GeomAbs
import OCC.TColStd
import OCC.TCollection
import OCC.MMgt
import OCC.gp
import OCC.Geom
import OCC.TColgp
import OCC.Adaptor2d
import OCC.Geom2d
import OCC.TopAbs
import OCC.math
import OCC.AppCont
import OCC.AppParCurves

_Approx.Approx_ChordLength_swigconstant(_Approx)
Approx_ChordLength = _Approx.Approx_ChordLength

_Approx.Approx_Centripetal_swigconstant(_Approx)
Approx_Centripetal = _Approx.Approx_Centripetal

_Approx.Approx_IsoParametric_swigconstant(_Approx)
Approx_IsoParametric = _Approx.Approx_IsoParametric

_Approx.Approx_PointsAdded_swigconstant(_Approx)
Approx_PointsAdded = _Approx.Approx_PointsAdded

_Approx.Approx_NoPointsAdded_swigconstant(_Approx)
Approx_NoPointsAdded = _Approx.Approx_NoPointsAdded

_Approx.Approx_NoApproximation_swigconstant(_Approx)
Approx_NoApproximation = _Approx.Approx_NoApproximation
class Approx_Array1OfAdHSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        :param Item:
        :type Item: Handle_Adaptor3d_HSurface &
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        """
        _Approx.Approx_Array1OfAdHSurface_swiginit(self, _Approx.new_Approx_Array1OfAdHSurface(*args))

    def Init(self, *args):
        """
        :param V:
        :type V: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        return _Approx.Approx_Array1OfAdHSurface_Init(self, *args)


    def Destroy(self, *args):
        """
        :rtype: None

        """
        return _Approx.Approx_Array1OfAdHSurface_Destroy(self, *args)


    def IsAllocated(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_Array1OfAdHSurface_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        :param Other:
        :type Other: Approx_Array1OfAdHSurface &
        :rtype: Approx_Array1OfAdHSurface

        """
        return _Approx.Approx_Array1OfAdHSurface_Assign(self, *args)


    def Set(self, *args):
        """
        :param Other:
        :type Other: Approx_Array1OfAdHSurface &
        :rtype: Approx_Array1OfAdHSurface

        """
        return _Approx.Approx_Array1OfAdHSurface_Set(self, *args)


    def Length(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfAdHSurface_Length(self, *args)


    def Lower(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfAdHSurface_Lower(self, *args)


    def Upper(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfAdHSurface_Upper(self, *args)


    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param Value:
        :type Value: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        return _Approx.Approx_Array1OfAdHSurface_SetValue(self, *args)


    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _Approx.Approx_Array1OfAdHSurface_Value(self, *args)


    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _Approx.Approx_Array1OfAdHSurface_ChangeValue(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_Array1OfAdHSurface.Init = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Init, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Destroy = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Destroy, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.IsAllocated = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_IsAllocated, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Assign = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Assign, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Set = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Set, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Length = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Length, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Lower = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Lower, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Upper = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Upper, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.SetValue = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_SetValue, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Value = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Value, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.ChangeValue = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_ChangeValue, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface._kill_pointed = new_instancemethod(_Approx.Approx_Array1OfAdHSurface__kill_pointed, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface_swigregister = _Approx.Approx_Array1OfAdHSurface_swigregister
Approx_Array1OfAdHSurface_swigregister(Approx_Array1OfAdHSurface)

class Approx_Array1OfGTrsf2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        :param Item:
        :type Item: gp_GTrsf2d
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        """
        _Approx.Approx_Array1OfGTrsf2d_swiginit(self, _Approx.new_Approx_Array1OfGTrsf2d(*args))

    def Init(self, *args):
        """
        :param V:
        :type V: gp_GTrsf2d
        :rtype: None

        """
        return _Approx.Approx_Array1OfGTrsf2d_Init(self, *args)


    def Destroy(self, *args):
        """
        :rtype: None

        """
        return _Approx.Approx_Array1OfGTrsf2d_Destroy(self, *args)


    def IsAllocated(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_Array1OfGTrsf2d_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        :param Other:
        :type Other: Approx_Array1OfGTrsf2d &
        :rtype: Approx_Array1OfGTrsf2d

        """
        return _Approx.Approx_Array1OfGTrsf2d_Assign(self, *args)


    def Set(self, *args):
        """
        :param Other:
        :type Other: Approx_Array1OfGTrsf2d &
        :rtype: Approx_Array1OfGTrsf2d

        """
        return _Approx.Approx_Array1OfGTrsf2d_Set(self, *args)


    def Length(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfGTrsf2d_Length(self, *args)


    def Lower(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfGTrsf2d_Lower(self, *args)


    def Upper(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfGTrsf2d_Upper(self, *args)


    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param Value:
        :type Value: gp_GTrsf2d
        :rtype: None

        """
        return _Approx.Approx_Array1OfGTrsf2d_SetValue(self, *args)


    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: gp_GTrsf2d

        """
        return _Approx.Approx_Array1OfGTrsf2d_Value(self, *args)


    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: gp_GTrsf2d

        """
        return _Approx.Approx_Array1OfGTrsf2d_ChangeValue(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_Array1OfGTrsf2d.Init = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Init, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Destroy = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Destroy, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.IsAllocated = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_IsAllocated, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Assign = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Assign, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Set = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Set, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Length = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Length, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Lower = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Lower, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Upper = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Upper, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.SetValue = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_SetValue, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Value = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Value, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.ChangeValue = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_ChangeValue, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d._kill_pointed = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d__kill_pointed, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d_swigregister = _Approx.Approx_Array1OfGTrsf2d_swigregister
Approx_Array1OfGTrsf2d_swigregister(Approx_Array1OfGTrsf2d)

class Approx_Curve2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param C2D:
        :type C2D: Handle_Adaptor2d_HCurve2d &
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param TolU:
        :type TolU: float
        :param TolV:
        :type TolV: float
        :param Continuity:
        :type Continuity: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSegments:
        :type MaxSegments: int
        :rtype: None

        """
        _Approx.Approx_Curve2d_swiginit(self, _Approx.new_Approx_Curve2d(*args))

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_Curve2d_IsDone(self, *args)


    def HasResult(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_Curve2d_HasResult(self, *args)


    def Curve(self, *args):
        """
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_Curve2d_Curve(self, *args)


    def MaxError2dU(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_Curve2d_MaxError2dU(self, *args)


    def MaxError2dV(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_Curve2d_MaxError2dV(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_Curve2d.IsDone = new_instancemethod(_Approx.Approx_Curve2d_IsDone, None, Approx_Curve2d)
Approx_Curve2d.HasResult = new_instancemethod(_Approx.Approx_Curve2d_HasResult, None, Approx_Curve2d)
Approx_Curve2d.Curve = new_instancemethod(_Approx.Approx_Curve2d_Curve, None, Approx_Curve2d)
Approx_Curve2d.MaxError2dU = new_instancemethod(_Approx.Approx_Curve2d_MaxError2dU, None, Approx_Curve2d)
Approx_Curve2d.MaxError2dV = new_instancemethod(_Approx.Approx_Curve2d_MaxError2dV, None, Approx_Curve2d)
Approx_Curve2d._kill_pointed = new_instancemethod(_Approx.Approx_Curve2d__kill_pointed, None, Approx_Curve2d)
Approx_Curve2d_swigregister = _Approx.Approx_Curve2d_swigregister
Approx_Curve2d_swigregister(Approx_Curve2d)

class Approx_Curve3d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Approximation of a curve with respect of the requiered tolerance Tol3D.

        :param Curve:
        :type Curve: Handle_Adaptor3d_HCurve &
        :param Tol3d:
        :type Tol3d: float
        :param Order:
        :type Order: GeomAbs_Shape
        :param MaxSegments:
        :type MaxSegments: int
        :param MaxDegree:
        :type MaxDegree: int
        :rtype: None

        """
        _Approx.Approx_Curve3d_swiginit(self, _Approx.new_Approx_Curve3d(*args))

    def Curve(self, *args):
        """
        :rtype: Handle_Geom_BSplineCurve

        """
        return _Approx.Approx_Curve3d_Curve(self, *args)


    def IsDone(self, *args):
        """
        * returns Standard_True if the approximation has been done within requiered tolerance

        :rtype: bool

        """
        return _Approx.Approx_Curve3d_IsDone(self, *args)


    def HasResult(self, *args):
        """
        * returns Standard_True if the approximation did come out with a result that is not NECESSARELY within the required tolerance

        :rtype: bool

        """
        return _Approx.Approx_Curve3d_HasResult(self, *args)


    def MaxError(self, *args):
        """
        * returns the Maximum Error (>0 when an approximation has been done, 0 if no approximation)

        :rtype: float

        """
        return _Approx.Approx_Curve3d_MaxError(self, *args)


    def DumpToString(self):
        """DumpToString(Approx_Curve3d self) -> std::string"""
        return _Approx.Approx_Curve3d_DumpToString(self)


    def _kill_pointed(self):
        """_kill_pointed(Approx_Curve3d self)"""
        return _Approx.Approx_Curve3d__kill_pointed(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_Curve3d.Curve = new_instancemethod(_Approx.Approx_Curve3d_Curve, None, Approx_Curve3d)
Approx_Curve3d.IsDone = new_instancemethod(_Approx.Approx_Curve3d_IsDone, None, Approx_Curve3d)
Approx_Curve3d.HasResult = new_instancemethod(_Approx.Approx_Curve3d_HasResult, None, Approx_Curve3d)
Approx_Curve3d.MaxError = new_instancemethod(_Approx.Approx_Curve3d_MaxError, None, Approx_Curve3d)
Approx_Curve3d.DumpToString = new_instancemethod(_Approx.Approx_Curve3d_DumpToString, None, Approx_Curve3d)
Approx_Curve3d._kill_pointed = new_instancemethod(_Approx.Approx_Curve3d__kill_pointed, None, Approx_Curve3d)
Approx_Curve3d_swigregister = _Approx.Approx_Curve3d_swigregister
Approx_Curve3d_swigregister(Approx_Curve3d)

class Approx_CurveOnSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param C2D:
        :type C2D: Handle_Adaptor2d_HCurve2d &
        :param Surf:
        :type Surf: Handle_Adaptor3d_HSurface &
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Tol:
        :type Tol: float
        :param Continuity:
        :type Continuity: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSegments:
        :type MaxSegments: int
        :param Only3d: default value is Standard_False
        :type Only3d: bool
        :param Only2d: default value is Standard_False
        :type Only2d: bool
        :rtype: None

        """
        _Approx.Approx_CurveOnSurface_swiginit(self, _Approx.new_Approx_CurveOnSurface(*args))

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_CurveOnSurface_IsDone(self, *args)


    def HasResult(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_CurveOnSurface_HasResult(self, *args)


    def Curve3d(self, *args):
        """
        :rtype: Handle_Geom_BSplineCurve

        """
        return _Approx.Approx_CurveOnSurface_Curve3d(self, *args)


    def MaxError3d(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_CurveOnSurface_MaxError3d(self, *args)


    def Curve2d(self, *args):
        """
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_CurveOnSurface_Curve2d(self, *args)


    def MaxError2dU(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_CurveOnSurface_MaxError2dU(self, *args)


    def MaxError2dV(self, *args):
        """
        * returns the maximum errors relativly to the U component or the V component of the  2d Curve

        :rtype: float

        """
        return _Approx.Approx_CurveOnSurface_MaxError2dV(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_CurveOnSurface.IsDone = new_instancemethod(_Approx.Approx_CurveOnSurface_IsDone, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.HasResult = new_instancemethod(_Approx.Approx_CurveOnSurface_HasResult, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.Curve3d = new_instancemethod(_Approx.Approx_CurveOnSurface_Curve3d, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.MaxError3d = new_instancemethod(_Approx.Approx_CurveOnSurface_MaxError3d, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.Curve2d = new_instancemethod(_Approx.Approx_CurveOnSurface_Curve2d, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.MaxError2dU = new_instancemethod(_Approx.Approx_CurveOnSurface_MaxError2dU, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.MaxError2dV = new_instancemethod(_Approx.Approx_CurveOnSurface_MaxError2dV, None, Approx_CurveOnSurface)
Approx_CurveOnSurface._kill_pointed = new_instancemethod(_Approx.Approx_CurveOnSurface__kill_pointed, None, Approx_CurveOnSurface)
Approx_CurveOnSurface_swigregister = _Approx.Approx_CurveOnSurface_swigregister
Approx_CurveOnSurface_swigregister(Approx_CurveOnSurface)

class Approx_CurvilinearParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * case of a free 3D curve

        :param C3D:
        :type C3D: Handle_Adaptor3d_HCurve &
        :param Tol:
        :type Tol: float
        :param Order:
        :type Order: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSegments:
        :type MaxSegments: int
        :rtype: None

        * case of a curve on one surface

        :param C2D:
        :type C2D: Handle_Adaptor2d_HCurve2d &
        :param Surf:
        :type Surf: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :param Order:
        :type Order: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSegments:
        :type MaxSegments: int
        :rtype: None

        * case of a curve on two surfaces

        :param C2D1:
        :type C2D1: Handle_Adaptor2d_HCurve2d &
        :param Surf1:
        :type Surf1: Handle_Adaptor3d_HSurface &
        :param C2D2:
        :type C2D2: Handle_Adaptor2d_HCurve2d &
        :param Surf2:
        :type Surf2: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :param Order:
        :type Order: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSegments:
        :type MaxSegments: int
        :rtype: None

        """
        _Approx.Approx_CurvilinearParameter_swiginit(self, _Approx.new_Approx_CurvilinearParameter(*args))

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_CurvilinearParameter_IsDone(self, *args)


    def HasResult(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_CurvilinearParameter_HasResult(self, *args)


    def Curve3d(self, *args):
        """
        * returns the Bspline curve corresponding to the reparametrized 3D curve

        :rtype: Handle_Geom_BSplineCurve

        """
        return _Approx.Approx_CurvilinearParameter_Curve3d(self, *args)


    def MaxError3d(self, *args):
        """
        * returns the maximum error on the reparametrized 3D curve

        :rtype: float

        """
        return _Approx.Approx_CurvilinearParameter_MaxError3d(self, *args)


    def Curve2d1(self, *args):
        """
        * returns the BsplineCurve representing the reparametrized 2D curve on the first surface (case of a curve on one or two surfaces)

        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_CurvilinearParameter_Curve2d1(self, *args)


    def MaxError2d1(self, *args):
        """
        * returns the maximum error on the first reparametrized 2D curve

        :rtype: float

        """
        return _Approx.Approx_CurvilinearParameter_MaxError2d1(self, *args)


    def Curve2d2(self, *args):
        """
        * returns the BsplineCurve representing the reparametrized 2D curve on the second surface (case of a curve on two surfaces)

        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_CurvilinearParameter_Curve2d2(self, *args)


    def MaxError2d2(self, *args):
        """
        * returns the maximum error on the second reparametrized 2D curve

        :rtype: float

        """
        return _Approx.Approx_CurvilinearParameter_MaxError2d2(self, *args)


    def DumpToString(self):
        """DumpToString(Approx_CurvilinearParameter self) -> std::string"""
        return _Approx.Approx_CurvilinearParameter_DumpToString(self)


    def _kill_pointed(self):
        """_kill_pointed(Approx_CurvilinearParameter self)"""
        return _Approx.Approx_CurvilinearParameter__kill_pointed(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_CurvilinearParameter.IsDone = new_instancemethod(_Approx.Approx_CurvilinearParameter_IsDone, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.HasResult = new_instancemethod(_Approx.Approx_CurvilinearParameter_HasResult, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.Curve3d = new_instancemethod(_Approx.Approx_CurvilinearParameter_Curve3d, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.MaxError3d = new_instancemethod(_Approx.Approx_CurvilinearParameter_MaxError3d, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.Curve2d1 = new_instancemethod(_Approx.Approx_CurvilinearParameter_Curve2d1, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.MaxError2d1 = new_instancemethod(_Approx.Approx_CurvilinearParameter_MaxError2d1, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.Curve2d2 = new_instancemethod(_Approx.Approx_CurvilinearParameter_Curve2d2, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.MaxError2d2 = new_instancemethod(_Approx.Approx_CurvilinearParameter_MaxError2d2, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.DumpToString = new_instancemethod(_Approx.Approx_CurvilinearParameter_DumpToString, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter._kill_pointed = new_instancemethod(_Approx.Approx_CurvilinearParameter__kill_pointed, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter_swigregister = _Approx.Approx_CurvilinearParameter_swigregister
Approx_CurvilinearParameter_swigregister(Approx_CurvilinearParameter)

class Approx_CurvlinFunc(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param Tol:
        :type Tol: float
        :rtype: None

        :param C2D:
        :type C2D: Handle_Adaptor2d_HCurve2d &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        :param C2D1:
        :type C2D1: Handle_Adaptor2d_HCurve2d &
        :param C2D2:
        :type C2D2: Handle_Adaptor2d_HCurve2d &
        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        _Approx.Approx_CurvlinFunc_swiginit(self, _Approx.new_Approx_CurvlinFunc(*args))

    def SetTol(self, *args):
        """
        * //!---Purpose Update the tolerance to used

        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _Approx.Approx_CurvlinFunc_SetTol(self, *args)


    def FirstParameter(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_LastParameter(self, *args)


    def NbIntervals(self, *args):
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>

        :param S:
        :type S: GeomAbs_Shape
        :rtype: int

        """
        return _Approx.Approx_CurvlinFunc_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>.  The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()

        :param T:
        :type T: TColStd_Array1OfReal &
        :param S:
        :type S: GeomAbs_Shape
        :rtype: None

        """
        return _Approx.Approx_CurvlinFunc_Intervals(self, *args)


    def Trim(self, *args):
        """
        * if First < 0 or Last > 1

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _Approx.Approx_CurvlinFunc_Trim(self, *args)


    def Length(self, *args):
        """
        * Computes length of the curve.

        :rtype: None

        * Computes length of the curve segment.

        :param C:
        :type C: Adaptor3d_Curve &
        :param FirstU:
        :type FirstU: float
        :param LasrU:
        :type LasrU: float
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_Length(self, *args)


    def GetLength(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_GetLength(self, *args)


    def GetUParameter(self, *args):
        """
        * returns original parameter correponding S. if Case == 1 computation is performed on myC2D1 and mySurf1, otherwise it is done on myC2D2 and mySurf2.

        :param C:
        :type C: Adaptor3d_Curve &
        :param S:
        :type S: float
        :param NumberOfCurve:
        :type NumberOfCurve: int
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_GetUParameter(self, *args)


    def GetSParameter(self, *args):
        """
        * returns original parameter correponding S.

        :param U:
        :type U: float
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_GetSParameter(self, *args)


    def EvalCase1(self, *args):
        """
        * if myCase != 1

        :param S:
        :type S: float
        :param Order:
        :type Order: int
        :param Result:
        :type Result: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_CurvlinFunc_EvalCase1(self, *args)


    def EvalCase2(self, *args):
        """
        * if myCase != 2

        :param S:
        :type S: float
        :param Order:
        :type Order: int
        :param Result:
        :type Result: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_CurvlinFunc_EvalCase2(self, *args)


    def EvalCase3(self, *args):
        """
        * if myCase != 3

        :param S:
        :type S: float
        :param Order:
        :type Order: int
        :param Result:
        :type Result: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_CurvlinFunc_EvalCase3(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(Approx_CurvlinFunc self)"""
        return _Approx.Approx_CurvlinFunc__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(Approx_CurvlinFunc self) -> Handle_Approx_CurvlinFunc"""
        return _Approx.Approx_CurvlinFunc_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_CurvlinFunc.SetTol = new_instancemethod(_Approx.Approx_CurvlinFunc_SetTol, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.FirstParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_FirstParameter, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.LastParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_LastParameter, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.NbIntervals = new_instancemethod(_Approx.Approx_CurvlinFunc_NbIntervals, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.Intervals = new_instancemethod(_Approx.Approx_CurvlinFunc_Intervals, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.Trim = new_instancemethod(_Approx.Approx_CurvlinFunc_Trim, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.Length = new_instancemethod(_Approx.Approx_CurvlinFunc_Length, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.GetLength = new_instancemethod(_Approx.Approx_CurvlinFunc_GetLength, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.GetUParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_GetUParameter, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.GetSParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_GetSParameter, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.EvalCase1 = new_instancemethod(_Approx.Approx_CurvlinFunc_EvalCase1, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.EvalCase2 = new_instancemethod(_Approx.Approx_CurvlinFunc_EvalCase2, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.EvalCase3 = new_instancemethod(_Approx.Approx_CurvlinFunc_EvalCase3, None, Approx_CurvlinFunc)
Approx_CurvlinFunc._kill_pointed = new_instancemethod(_Approx.Approx_CurvlinFunc__kill_pointed, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.GetHandle = new_instancemethod(_Approx.Approx_CurvlinFunc_GetHandle, None, Approx_CurvlinFunc)
Approx_CurvlinFunc_swigregister = _Approx.Approx_CurvlinFunc_swigregister
Approx_CurvlinFunc_swigregister(Approx_CurvlinFunc)

class Handle_Approx_CurvlinFunc(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Approx.Handle_Approx_CurvlinFunc_swiginit(self, _Approx.new_Handle_Approx_CurvlinFunc(*args))
    DownCast = staticmethod(_Approx.Handle_Approx_CurvlinFunc_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_Approx_CurvlinFunc.Nullify = new_instancemethod(_Approx.Handle_Approx_CurvlinFunc_Nullify, None, Handle_Approx_CurvlinFunc)
Handle_Approx_CurvlinFunc.IsNull = new_instancemethod(_Approx.Handle_Approx_CurvlinFunc_IsNull, None, Handle_Approx_CurvlinFunc)
Handle_Approx_CurvlinFunc.GetObject = new_instancemethod(_Approx.Handle_Approx_CurvlinFunc_GetObject, None, Handle_Approx_CurvlinFunc)
Handle_Approx_CurvlinFunc._kill_pointed = new_instancemethod(_Approx.Handle_Approx_CurvlinFunc__kill_pointed, None, Handle_Approx_CurvlinFunc)
Handle_Approx_CurvlinFunc_swigregister = _Approx.Handle_Approx_CurvlinFunc_swigregister
Handle_Approx_CurvlinFunc_swigregister(Handle_Approx_CurvlinFunc)

def Handle_Approx_CurvlinFunc_DownCast(AnObject):
    return _Approx.Handle_Approx_CurvlinFunc_DownCast(AnObject)
Handle_Approx_CurvlinFunc_DownCast = _Approx.Handle_Approx_CurvlinFunc_DownCast

class Approx_FitAndDivide(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Line:
        :type Line: AppCont_Function &
        :param degreemin: default value is 3
        :type degreemin: int
        :param degreemax: default value is 8
        :type degreemax: int
        :param Tolerance3d: default value is 1.0e-5
        :type Tolerance3d: float
        :param Tolerance2d: default value is 1.0e-5
        :type Tolerance2d: float
        :param cutting: default value is Standard_False
        :type cutting: bool
        :param FirstC: default value is AppParCurves_TangencyPoint
        :type FirstC: AppParCurves_Constraint
        :param LastC: default value is AppParCurves_TangencyPoint
        :type LastC: AppParCurves_Constraint
        :rtype: None

        :param degreemin: default value is 3
        :type degreemin: int
        :param degreemax: default value is 8
        :type degreemax: int
        :param Tolerance3d: default value is 1.0e-05
        :type Tolerance3d: float
        :param Tolerance2d: default value is 1.0e-05
        :type Tolerance2d: float
        :param cutting: default value is Standard_False
        :type cutting: bool
        :param FirstC: default value is AppParCurves_TangencyPoint
        :type FirstC: AppParCurves_Constraint
        :param LastC: default value is AppParCurves_TangencyPoint
        :type LastC: AppParCurves_Constraint
        :rtype: None

        """
        _Approx.Approx_FitAndDivide_swiginit(self, _Approx.new_Approx_FitAndDivide(*args))

    def Perform(self, *args):
        """
        :param Line:
        :type Line: AppCont_Function &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_Perform(self, *args)


    def SetDegrees(self, *args):
        """
        :param degreemin:
        :type degreemin: int
        :param degreemax:
        :type degreemax: int
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        :param Tolerance3d:
        :type Tolerance3d: float
        :param Tolerance2d:
        :type Tolerance2d: float
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_SetTolerances(self, *args)


    def SetConstraints(self, *args):
        """
        :param FirstC:
        :type FirstC: AppParCurves_Constraint
        :param LastC:
        :type LastC: AppParCurves_Constraint
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_SetConstraints(self, *args)


    def IsAllApproximated(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_FitAndDivide_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_FitAndDivide_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        :param Index:
        :type Index: int
        :param tol3d:
        :type tol3d: float &
        :param tol2d:
        :type tol2d: float &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_Error(self, *args)


    def NbMultiCurves(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_FitAndDivide_NbMultiCurves(self, *args)


    def Value(self, *args):
        """
        :param Index: default value is 1
        :type Index: int
        :rtype: AppParCurves_MultiCurve

        """
        return _Approx.Approx_FitAndDivide_Value(self, *args)


    def Parameters(self, *args):
        """
        :param Index:
        :type Index: int
        :param firstp:
        :type firstp: float &
        :param lastp:
        :type lastp: float &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_Parameters(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_FitAndDivide.Perform = new_instancemethod(_Approx.Approx_FitAndDivide_Perform, None, Approx_FitAndDivide)
Approx_FitAndDivide.SetDegrees = new_instancemethod(_Approx.Approx_FitAndDivide_SetDegrees, None, Approx_FitAndDivide)
Approx_FitAndDivide.SetTolerances = new_instancemethod(_Approx.Approx_FitAndDivide_SetTolerances, None, Approx_FitAndDivide)
Approx_FitAndDivide.SetConstraints = new_instancemethod(_Approx.Approx_FitAndDivide_SetConstraints, None, Approx_FitAndDivide)
Approx_FitAndDivide.IsAllApproximated = new_instancemethod(_Approx.Approx_FitAndDivide_IsAllApproximated, None, Approx_FitAndDivide)
Approx_FitAndDivide.IsToleranceReached = new_instancemethod(_Approx.Approx_FitAndDivide_IsToleranceReached, None, Approx_FitAndDivide)
Approx_FitAndDivide.Error = new_instancemethod(_Approx.Approx_FitAndDivide_Error, None, Approx_FitAndDivide)
Approx_FitAndDivide.NbMultiCurves = new_instancemethod(_Approx.Approx_FitAndDivide_NbMultiCurves, None, Approx_FitAndDivide)
Approx_FitAndDivide.Value = new_instancemethod(_Approx.Approx_FitAndDivide_Value, None, Approx_FitAndDivide)
Approx_FitAndDivide.Parameters = new_instancemethod(_Approx.Approx_FitAndDivide_Parameters, None, Approx_FitAndDivide)
Approx_FitAndDivide._kill_pointed = new_instancemethod(_Approx.Approx_FitAndDivide__kill_pointed, None, Approx_FitAndDivide)
Approx_FitAndDivide_swigregister = _Approx.Approx_FitAndDivide_swigregister
Approx_FitAndDivide_swigregister(Approx_FitAndDivide)

class Approx_FitAndDivide2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Line:
        :type Line: AppCont_Function2d &
        :param degreemin: default value is 3
        :type degreemin: int
        :param degreemax: default value is 8
        :type degreemax: int
        :param Tolerance3d: default value is 1.0e-5
        :type Tolerance3d: float
        :param Tolerance2d: default value is 1.0e-5
        :type Tolerance2d: float
        :param cutting: default value is Standard_False
        :type cutting: bool
        :param FirstC: default value is AppParCurves_TangencyPoint
        :type FirstC: AppParCurves_Constraint
        :param LastC: default value is AppParCurves_TangencyPoint
        :type LastC: AppParCurves_Constraint
        :rtype: None

        :param degreemin: default value is 3
        :type degreemin: int
        :param degreemax: default value is 8
        :type degreemax: int
        :param Tolerance3d: default value is 1.0e-05
        :type Tolerance3d: float
        :param Tolerance2d: default value is 1.0e-05
        :type Tolerance2d: float
        :param cutting: default value is Standard_False
        :type cutting: bool
        :param FirstC: default value is AppParCurves_TangencyPoint
        :type FirstC: AppParCurves_Constraint
        :param LastC: default value is AppParCurves_TangencyPoint
        :type LastC: AppParCurves_Constraint
        :rtype: None

        """
        _Approx.Approx_FitAndDivide2d_swiginit(self, _Approx.new_Approx_FitAndDivide2d(*args))

    def Perform(self, *args):
        """
        :param Line:
        :type Line: AppCont_Function2d &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_Perform(self, *args)


    def SetDegrees(self, *args):
        """
        :param degreemin:
        :type degreemin: int
        :param degreemax:
        :type degreemax: int
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        :param Tolerance3d:
        :type Tolerance3d: float
        :param Tolerance2d:
        :type Tolerance2d: float
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_SetTolerances(self, *args)


    def SetConstraints(self, *args):
        """
        :param FirstC:
        :type FirstC: AppParCurves_Constraint
        :param LastC:
        :type LastC: AppParCurves_Constraint
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_SetConstraints(self, *args)


    def IsAllApproximated(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_FitAndDivide2d_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_FitAndDivide2d_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        :param Index:
        :type Index: int
        :param tol3d:
        :type tol3d: float &
        :param tol2d:
        :type tol2d: float &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_Error(self, *args)


    def NbMultiCurves(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_FitAndDivide2d_NbMultiCurves(self, *args)


    def Value(self, *args):
        """
        :param Index: default value is 1
        :type Index: int
        :rtype: AppParCurves_MultiCurve

        """
        return _Approx.Approx_FitAndDivide2d_Value(self, *args)


    def Parameters(self, *args):
        """
        :param Index:
        :type Index: int
        :param firstp:
        :type firstp: float &
        :param lastp:
        :type lastp: float &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_Parameters(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_FitAndDivide2d.Perform = new_instancemethod(_Approx.Approx_FitAndDivide2d_Perform, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetDegrees = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetDegrees, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetTolerances = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetTolerances, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetConstraints = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetConstraints, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.IsAllApproximated = new_instancemethod(_Approx.Approx_FitAndDivide2d_IsAllApproximated, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.IsToleranceReached = new_instancemethod(_Approx.Approx_FitAndDivide2d_IsToleranceReached, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.Error = new_instancemethod(_Approx.Approx_FitAndDivide2d_Error, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.NbMultiCurves = new_instancemethod(_Approx.Approx_FitAndDivide2d_NbMultiCurves, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.Value = new_instancemethod(_Approx.Approx_FitAndDivide2d_Value, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.Parameters = new_instancemethod(_Approx.Approx_FitAndDivide2d_Parameters, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d._kill_pointed = new_instancemethod(_Approx.Approx_FitAndDivide2d__kill_pointed, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d_swigregister = _Approx.Approx_FitAndDivide2d_swigregister
Approx_FitAndDivide2d_swigregister(Approx_FitAndDivide2d)

class Approx_HArray1OfAdHSurface(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :param V:
        :type V: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        _Approx.Approx_HArray1OfAdHSurface_swiginit(self, _Approx.new_Approx_HArray1OfAdHSurface(*args))

    def Init(self, *args):
        """
        :param V:
        :type V: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        return _Approx.Approx_HArray1OfAdHSurface_Init(self, *args)


    def Length(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfAdHSurface_Length(self, *args)


    def Lower(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfAdHSurface_Lower(self, *args)


    def Upper(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfAdHSurface_Upper(self, *args)


    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param Value:
        :type Value: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        return _Approx.Approx_HArray1OfAdHSurface_SetValue(self, *args)


    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _Approx.Approx_HArray1OfAdHSurface_Value(self, *args)


    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _Approx.Approx_HArray1OfAdHSurface_ChangeValue(self, *args)


    def Array1(self, *args):
        """
        :rtype: Approx_Array1OfAdHSurface

        """
        return _Approx.Approx_HArray1OfAdHSurface_Array1(self, *args)


    def ChangeArray1(self, *args):
        """
        :rtype: Approx_Array1OfAdHSurface

        """
        return _Approx.Approx_HArray1OfAdHSurface_ChangeArray1(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(Approx_HArray1OfAdHSurface self)"""
        return _Approx.Approx_HArray1OfAdHSurface__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(Approx_HArray1OfAdHSurface self) -> Handle_Approx_HArray1OfAdHSurface"""
        return _Approx.Approx_HArray1OfAdHSurface_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_HArray1OfAdHSurface.Init = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Init, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.Length = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Length, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.Lower = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Lower, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.Upper = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Upper, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.SetValue = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_SetValue, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.Value = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Value, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.ChangeValue = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_ChangeValue, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.Array1 = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Array1, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.ChangeArray1 = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_ChangeArray1, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface._kill_pointed = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface__kill_pointed, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.GetHandle = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_GetHandle, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface_swigregister = _Approx.Approx_HArray1OfAdHSurface_swigregister
Approx_HArray1OfAdHSurface_swigregister(Approx_HArray1OfAdHSurface)

class Handle_Approx_HArray1OfAdHSurface(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Approx.Handle_Approx_HArray1OfAdHSurface_swiginit(self, _Approx.new_Handle_Approx_HArray1OfAdHSurface(*args))
    DownCast = staticmethod(_Approx.Handle_Approx_HArray1OfAdHSurface_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_Approx_HArray1OfAdHSurface.Nullify = new_instancemethod(_Approx.Handle_Approx_HArray1OfAdHSurface_Nullify, None, Handle_Approx_HArray1OfAdHSurface)
Handle_Approx_HArray1OfAdHSurface.IsNull = new_instancemethod(_Approx.Handle_Approx_HArray1OfAdHSurface_IsNull, None, Handle_Approx_HArray1OfAdHSurface)
Handle_Approx_HArray1OfAdHSurface.GetObject = new_instancemethod(_Approx.Handle_Approx_HArray1OfAdHSurface_GetObject, None, Handle_Approx_HArray1OfAdHSurface)
Handle_Approx_HArray1OfAdHSurface._kill_pointed = new_instancemethod(_Approx.Handle_Approx_HArray1OfAdHSurface__kill_pointed, None, Handle_Approx_HArray1OfAdHSurface)
Handle_Approx_HArray1OfAdHSurface_swigregister = _Approx.Handle_Approx_HArray1OfAdHSurface_swigregister
Handle_Approx_HArray1OfAdHSurface_swigregister(Handle_Approx_HArray1OfAdHSurface)

def Handle_Approx_HArray1OfAdHSurface_DownCast(AnObject):
    return _Approx.Handle_Approx_HArray1OfAdHSurface_DownCast(AnObject)
Handle_Approx_HArray1OfAdHSurface_DownCast = _Approx.Handle_Approx_HArray1OfAdHSurface_DownCast

class Approx_HArray1OfGTrsf2d(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :param V:
        :type V: gp_GTrsf2d
        :rtype: None

        """
        _Approx.Approx_HArray1OfGTrsf2d_swiginit(self, _Approx.new_Approx_HArray1OfGTrsf2d(*args))

    def Init(self, *args):
        """
        :param V:
        :type V: gp_GTrsf2d
        :rtype: None

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Init(self, *args)


    def Length(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Length(self, *args)


    def Lower(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Lower(self, *args)


    def Upper(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Upper(self, *args)


    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param Value:
        :type Value: gp_GTrsf2d
        :rtype: None

        """
        return _Approx.Approx_HArray1OfGTrsf2d_SetValue(self, *args)


    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: gp_GTrsf2d

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Value(self, *args)


    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: gp_GTrsf2d

        """
        return _Approx.Approx_HArray1OfGTrsf2d_ChangeValue(self, *args)


    def Array1(self, *args):
        """
        :rtype: Approx_Array1OfGTrsf2d

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Array1(self, *args)


    def ChangeArray1(self, *args):
        """
        :rtype: Approx_Array1OfGTrsf2d

        """
        return _Approx.Approx_HArray1OfGTrsf2d_ChangeArray1(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(Approx_HArray1OfGTrsf2d self)"""
        return _Approx.Approx_HArray1OfGTrsf2d__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(Approx_HArray1OfGTrsf2d self) -> Handle_Approx_HArray1OfGTrsf2d"""
        return _Approx.Approx_HArray1OfGTrsf2d_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_HArray1OfGTrsf2d.Init = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Init, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.Length = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Length, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.Lower = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Lower, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.Upper = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Upper, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.SetValue = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_SetValue, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.Value = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Value, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.ChangeValue = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_ChangeValue, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.Array1 = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Array1, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.ChangeArray1 = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_ChangeArray1, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d._kill_pointed = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d__kill_pointed, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.GetHandle = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_GetHandle, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d_swigregister = _Approx.Approx_HArray1OfGTrsf2d_swigregister
Approx_HArray1OfGTrsf2d_swigregister(Approx_HArray1OfGTrsf2d)

class Handle_Approx_HArray1OfGTrsf2d(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Approx.Handle_Approx_HArray1OfGTrsf2d_swiginit(self, _Approx.new_Handle_Approx_HArray1OfGTrsf2d(*args))
    DownCast = staticmethod(_Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_Approx_HArray1OfGTrsf2d.Nullify = new_instancemethod(_Approx.Handle_Approx_HArray1OfGTrsf2d_Nullify, None, Handle_Approx_HArray1OfGTrsf2d)
Handle_Approx_HArray1OfGTrsf2d.IsNull = new_instancemethod(_Approx.Handle_Approx_HArray1OfGTrsf2d_IsNull, None, Handle_Approx_HArray1OfGTrsf2d)
Handle_Approx_HArray1OfGTrsf2d.GetObject = new_instancemethod(_Approx.Handle_Approx_HArray1OfGTrsf2d_GetObject, None, Handle_Approx_HArray1OfGTrsf2d)
Handle_Approx_HArray1OfGTrsf2d._kill_pointed = new_instancemethod(_Approx.Handle_Approx_HArray1OfGTrsf2d__kill_pointed, None, Handle_Approx_HArray1OfGTrsf2d)
Handle_Approx_HArray1OfGTrsf2d_swigregister = _Approx.Handle_Approx_HArray1OfGTrsf2d_swigregister
Handle_Approx_HArray1OfGTrsf2d_swigregister(Handle_Approx_HArray1OfGTrsf2d)

def Handle_Approx_HArray1OfGTrsf2d_DownCast(AnObject):
    return _Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast(AnObject)
Handle_Approx_HArray1OfGTrsf2d_DownCast = _Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast

class Approx_MCurvesToBSpCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _Approx.Approx_MCurvesToBSpCurve_swiginit(self, _Approx.new_Approx_MCurvesToBSpCurve(*args))

    def Reset(self, *args):
        """
        :rtype: None

        """
        return _Approx.Approx_MCurvesToBSpCurve_Reset(self, *args)


    def Append(self, *args):
        """
        :param MC:
        :type MC: AppParCurves_MultiCurve &
        :rtype: None

        """
        return _Approx.Approx_MCurvesToBSpCurve_Append(self, *args)


    def Perform(self, *args):
        """
        :rtype: None

        :param TheSeq:
        :type TheSeq: AppParCurves_SequenceOfMultiCurve &
        :rtype: None

        """
        return _Approx.Approx_MCurvesToBSpCurve_Perform(self, *args)


    def Value(self, *args):
        """
        * return the composite MultiCurves as a MultiBSpCurve.

        :rtype: AppParCurves_MultiBSpCurve

        """
        return _Approx.Approx_MCurvesToBSpCurve_Value(self, *args)


    def ChangeValue(self, *args):
        """
        * return the composite MultiCurves as a MultiBSpCurve.

        :rtype: AppParCurves_MultiBSpCurve

        """
        return _Approx.Approx_MCurvesToBSpCurve_ChangeValue(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_MCurvesToBSpCurve.Reset = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Reset, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.Append = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Append, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.Perform = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Perform, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.Value = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Value, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.ChangeValue = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_ChangeValue, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve._kill_pointed = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve__kill_pointed, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve_swigregister = _Approx.Approx_MCurvesToBSpCurve_swigregister
Approx_MCurvesToBSpCurve_swigregister(Approx_MCurvesToBSpCurve)

class Approx_MyLeastSquareOfFitAndDivide(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param SSP:
        :type SSP: AppCont_Function &
        :param U0:
        :type U0: float
        :param U1:
        :type U1: float
        :param FirstCons:
        :type FirstCons: AppParCurves_Constraint
        :param LastCons:
        :type LastCons: AppParCurves_Constraint
        :param Deg:
        :type Deg: int
        :param NbPoints: default value is 24
        :type NbPoints: int
        :rtype: None

        """
        _Approx.Approx_MyLeastSquareOfFitAndDivide_swiginit(self, _Approx.new_Approx_MyLeastSquareOfFitAndDivide(*args))

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide_IsDone(self, *args)


    def Value(self, *args):
        """
        :rtype: AppParCurves_MultiCurve

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide_Value(self, *args)


    def Error(self, *args):
        """
        :param F:
        :type F: float &
        :param MaxE3d:
        :type MaxE3d: float &
        :param MaxE2d:
        :type MaxE2d: float &
        :rtype: None

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide_Error(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_MyLeastSquareOfFitAndDivide.IsDone = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide_IsDone, None, Approx_MyLeastSquareOfFitAndDivide)
Approx_MyLeastSquareOfFitAndDivide.Value = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide_Value, None, Approx_MyLeastSquareOfFitAndDivide)
Approx_MyLeastSquareOfFitAndDivide.Error = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide_Error, None, Approx_MyLeastSquareOfFitAndDivide)
Approx_MyLeastSquareOfFitAndDivide._kill_pointed = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide__kill_pointed, None, Approx_MyLeastSquareOfFitAndDivide)
Approx_MyLeastSquareOfFitAndDivide_swigregister = _Approx.Approx_MyLeastSquareOfFitAndDivide_swigregister
Approx_MyLeastSquareOfFitAndDivide_swigregister(Approx_MyLeastSquareOfFitAndDivide)

class Approx_MyLeastSquareOfFitAndDivide2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param SSP:
        :type SSP: AppCont_Function2d &
        :param U0:
        :type U0: float
        :param U1:
        :type U1: float
        :param FirstCons:
        :type FirstCons: AppParCurves_Constraint
        :param LastCons:
        :type LastCons: AppParCurves_Constraint
        :param Deg:
        :type Deg: int
        :param NbPoints: default value is 24
        :type NbPoints: int
        :rtype: None

        """
        _Approx.Approx_MyLeastSquareOfFitAndDivide2d_swiginit(self, _Approx.new_Approx_MyLeastSquareOfFitAndDivide2d(*args))

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide2d_IsDone(self, *args)


    def Value(self, *args):
        """
        :rtype: AppParCurves_MultiCurve

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide2d_Value(self, *args)


    def Error(self, *args):
        """
        :param F:
        :type F: float &
        :param MaxE3d:
        :type MaxE3d: float &
        :param MaxE2d:
        :type MaxE2d: float &
        :rtype: None

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide2d_Error(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_MyLeastSquareOfFitAndDivide2d.IsDone = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide2d_IsDone, None, Approx_MyLeastSquareOfFitAndDivide2d)
Approx_MyLeastSquareOfFitAndDivide2d.Value = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide2d_Value, None, Approx_MyLeastSquareOfFitAndDivide2d)
Approx_MyLeastSquareOfFitAndDivide2d.Error = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide2d_Error, None, Approx_MyLeastSquareOfFitAndDivide2d)
Approx_MyLeastSquareOfFitAndDivide2d._kill_pointed = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide2d__kill_pointed, None, Approx_MyLeastSquareOfFitAndDivide2d)
Approx_MyLeastSquareOfFitAndDivide2d_swigregister = _Approx.Approx_MyLeastSquareOfFitAndDivide2d_swigregister
Approx_MyLeastSquareOfFitAndDivide2d_swigregister(Approx_MyLeastSquareOfFitAndDivide2d)

class Approx_SameParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Warning: the C3D and C2D must have the same parametric domain.

        :param C3D:
        :type C3D: Handle_Geom_Curve &
        :param C2D:
        :type C2D: Handle_Geom2d_Curve &
        :param S:
        :type S: Handle_Geom_Surface &
        :param Tol:
        :type Tol: float
        :rtype: None

        :param C3D:
        :type C3D: Handle_Adaptor3d_HCurve &
        :param C2D:
        :type C2D: Handle_Geom2d_Curve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        * Warning: the C3D and C2D must have the same parametric domain.

        :param C3D:
        :type C3D: Handle_Adaptor3d_HCurve &
        :param C2D:
        :type C2D: Handle_Adaptor2d_HCurve2d &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        _Approx.Approx_SameParameter_swiginit(self, _Approx.new_Approx_SameParameter(*args))

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_SameParameter_IsDone(self, *args)


    def TolReached(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_SameParameter_TolReached(self, *args)


    def IsSameParameter(self, *args):
        """
        * Tells whether the original data had already the same parameter up to the tolerance : in that case nothing is done.

        :rtype: bool

        """
        return _Approx.Approx_SameParameter_IsSameParameter(self, *args)


    def Curve2d(self, *args):
        """
        * Returns the 2D curve that has the same parameter as the 3D curve once evaluated on the surface up to the specified tolerance

        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_SameParameter_Curve2d(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_SameParameter.IsDone = new_instancemethod(_Approx.Approx_SameParameter_IsDone, None, Approx_SameParameter)
Approx_SameParameter.TolReached = new_instancemethod(_Approx.Approx_SameParameter_TolReached, None, Approx_SameParameter)
Approx_SameParameter.IsSameParameter = new_instancemethod(_Approx.Approx_SameParameter_IsSameParameter, None, Approx_SameParameter)
Approx_SameParameter.Curve2d = new_instancemethod(_Approx.Approx_SameParameter_Curve2d, None, Approx_SameParameter)
Approx_SameParameter._kill_pointed = new_instancemethod(_Approx.Approx_SameParameter__kill_pointed, None, Approx_SameParameter)
Approx_SameParameter_swigregister = _Approx.Approx_SameParameter_swigregister
Approx_SameParameter_swigregister(Approx_SameParameter)

class Approx_SequenceNodeOfSequenceOfHArray1OfReal(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param I:
        :type I: Handle_TColStd_HArray1OfReal &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal_swiginit(self, _Approx.new_Approx_SequenceNodeOfSequenceOfHArray1OfReal(*args))

    def Value(self, *args):
        """
        :rtype: Handle_TColStd_HArray1OfReal

        """
        return _Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal_Value(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(Approx_SequenceNodeOfSequenceOfHArray1OfReal self)"""
        return _Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(Approx_SequenceNodeOfSequenceOfHArray1OfReal self) -> Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal"""
        return _Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_SequenceNodeOfSequenceOfHArray1OfReal.Value = new_instancemethod(_Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal_Value, None, Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Approx_SequenceNodeOfSequenceOfHArray1OfReal._kill_pointed = new_instancemethod(_Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal__kill_pointed, None, Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Approx_SequenceNodeOfSequenceOfHArray1OfReal.GetHandle = new_instancemethod(_Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal_GetHandle, None, Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister = _Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister
Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister(Approx_SequenceNodeOfSequenceOfHArray1OfReal)

class Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_swiginit(self, _Approx.new_Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal(*args))
    DownCast = staticmethod(_Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal.Nullify = new_instancemethod(_Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_Nullify, None, Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal.IsNull = new_instancemethod(_Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_IsNull, None, Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal.GetObject = new_instancemethod(_Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_GetObject, None, Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal._kill_pointed = new_instancemethod(_Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal__kill_pointed, None, Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister = _Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister(Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal)

def Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_DownCast(AnObject):
    return _Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_DownCast(AnObject)
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_DownCast = _Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_DownCast

class Approx_SequenceOfHArray1OfReal(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None

        """
        _Approx.Approx_SequenceOfHArray1OfReal_swiginit(self, _Approx.new_Approx_SequenceOfHArray1OfReal(*args))

    def Clear(self, *args):
        """
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Clear(self, *args)


    def Assign(self, *args):
        """
        :param Other:
        :type Other: Approx_SequenceOfHArray1OfReal &
        :rtype: Approx_SequenceOfHArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Assign(self, *args)


    def Set(self, *args):
        """
        :param Other:
        :type Other: Approx_SequenceOfHArray1OfReal &
        :rtype: Approx_SequenceOfHArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Set(self, *args)


    def Append(self, *args):
        """
        :param T:
        :type T: Handle_TColStd_HArray1OfReal &
        :rtype: None

        :param S:
        :type S: Approx_SequenceOfHArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Append(self, *args)


    def Prepend(self, *args):
        """
        :param T:
        :type T: Handle_TColStd_HArray1OfReal &
        :rtype: None

        :param S:
        :type S: Approx_SequenceOfHArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_TColStd_HArray1OfReal &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Approx_SequenceOfHArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_TColStd_HArray1OfReal &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Approx_SequenceOfHArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_InsertAfter(self, *args)


    def First(self, *args):
        """
        :rtype: Handle_TColStd_HArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_First(self, *args)


    def Last(self, *args):
        """
        :rtype: Handle_TColStd_HArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Last(self, *args)


    def Split(self, *args):
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: Approx_SequenceOfHArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Split(self, *args)


    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_TColStd_HArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Value(self, *args)


    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_TColStd_HArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_SetValue(self, *args)


    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_TColStd_HArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_ChangeValue(self, *args)


    def Remove(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Remove(self, *args)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_SequenceOfHArray1OfReal.Clear = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Clear, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Assign = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Assign, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Set = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Set, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Append = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Append, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Prepend = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Prepend, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.InsertBefore = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_InsertBefore, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.InsertAfter = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_InsertAfter, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.First = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_First, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Last = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Last, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Split = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Split, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Value = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Value, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.SetValue = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_SetValue, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.ChangeValue = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_ChangeValue, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Remove = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Remove, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal._kill_pointed = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal__kill_pointed, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal_swigregister = _Approx.Approx_SequenceOfHArray1OfReal_swigregister
Approx_SequenceOfHArray1OfReal_swigregister(Approx_SequenceOfHArray1OfReal)

class Approx_SweepApproximation(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Func:
        :type Func: Handle_Approx_SweepFunction &
        :rtype: None

        """
        _Approx.Approx_SweepApproximation_swiginit(self, _Approx.new_Approx_SweepApproximation(*args))

    def Perform(self, *args):
        """
        * Perform the Approximation [First, Last] : Approx_SweepApproximation.cdl Tol3d : Tolerance to surface approximation Tol2d : Tolerance used to perform curve approximation  Normaly the 2d curve are approximated with a  tolerance given by the resolution on support surfaces,  but if this tolerance is too large Tol2d is used. TolAngular : Tolerance (in radian) to control the angle  beetween tangents on the section law and  tangent of iso-v on approximed surface Continuity : The continuity in v waiting on the surface Degmax : The maximum degree in v requiered on the surface Segmax : The maximum number of span in v requiered on  the surface Warning : The continuity ci can be obtained only if Ft is Ci

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Tol3d:
        :type Tol3d: float
        :param BoundTol:
        :type BoundTol: float
        :param Tol2d:
        :type Tol2d: float
        :param TolAngular:
        :type TolAngular: float
        :param Continuity: default value is GeomAbs_C0
        :type Continuity: GeomAbs_Shape
        :param Degmax: default value is 11
        :type Degmax: int
        :param Segmax: default value is 50
        :type Segmax: int
        :rtype: None

        """
        return _Approx.Approx_SweepApproximation_Perform(self, *args)


    def Eval(self, *args):
        """
        * The EvaluatorFunction from AdvApprox;

        :param Parameter:
        :type Parameter: float
        :param DerivativeRequest:
        :type DerivativeRequest: int
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Result:
        :type Result: float &
        :rtype: int

        """
        return _Approx.Approx_SweepApproximation_Eval(self, *args)


    def IsDone(self, *args):
        """
        * returns if we have an result

        :rtype: bool

        """
        return _Approx.Approx_SweepApproximation_IsDone(self, *args)


    def SurfShape(self, *args):
        """
        :param UDegree:
        :type UDegree: int &
        :param VDegree:
        :type VDegree: int &
        :param NbUPoles:
        :type NbUPoles: int &
        :param NbVPoles:
        :type NbVPoles: int &
        :param NbUKnots:
        :type NbUKnots: int &
        :param NbVKnots:
        :type NbVKnots: int &
        :rtype: None

        """
        return _Approx.Approx_SweepApproximation_SurfShape(self, *args)


    def Surface(self, *args):
        """
        :param TPoles:
        :type TPoles: TColgp_Array2OfPnt
        :param TWeights:
        :type TWeights: TColStd_Array2OfReal &
        :param TUKnots:
        :type TUKnots: TColStd_Array1OfReal &
        :param TVKnots:
        :type TVKnots: TColStd_Array1OfReal &
        :param TUMults:
        :type TUMults: TColStd_Array1OfInteger &
        :param TVMults:
        :type TVMults: TColStd_Array1OfInteger &
        :rtype: None

        """
        return _Approx.Approx_SweepApproximation_Surface(self, *args)


    def UDegree(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_SweepApproximation_UDegree(self, *args)


    def VDegree(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_SweepApproximation_VDegree(self, *args)


    def SurfPoles(self, *args):
        """
        :rtype: TColgp_Array2OfPnt

        """
        return _Approx.Approx_SweepApproximation_SurfPoles(self, *args)


    def SurfWeights(self, *args):
        """
        :rtype: TColStd_Array2OfReal

        """
        return _Approx.Approx_SweepApproximation_SurfWeights(self, *args)


    def SurfUKnots(self, *args):
        """
        :rtype: TColStd_Array1OfReal

        """
        return _Approx.Approx_SweepApproximation_SurfUKnots(self, *args)


    def SurfVKnots(self, *args):
        """
        :rtype: TColStd_Array1OfReal

        """
        return _Approx.Approx_SweepApproximation_SurfVKnots(self, *args)


    def SurfUMults(self, *args):
        """
        :rtype: TColStd_Array1OfInteger

        """
        return _Approx.Approx_SweepApproximation_SurfUMults(self, *args)


    def SurfVMults(self, *args):
        """
        :rtype: TColStd_Array1OfInteger

        """
        return _Approx.Approx_SweepApproximation_SurfVMults(self, *args)


    def MaxErrorOnSurf(self, *args):
        """
        * returns the maximum error in the suface approximation.

        :rtype: float

        """
        return _Approx.Approx_SweepApproximation_MaxErrorOnSurf(self, *args)


    def AverageErrorOnSurf(self, *args):
        """
        * returns the average error in the suface approximation.

        :rtype: float

        """
        return _Approx.Approx_SweepApproximation_AverageErrorOnSurf(self, *args)


    def NbCurves2d(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_SweepApproximation_NbCurves2d(self, *args)


    def Curves2dShape(self, *args):
        """
        :param Degree:
        :type Degree: int &
        :param NbPoles:
        :type NbPoles: int &
        :param NbKnots:
        :type NbKnots: int &
        :rtype: None

        """
        return _Approx.Approx_SweepApproximation_Curves2dShape(self, *args)


    def Curve2d(self, *args):
        """
        :param Index:
        :type Index: int
        :param TPoles:
        :type TPoles: TColgp_Array1OfPnt2d
        :param TKnots:
        :type TKnots: TColStd_Array1OfReal &
        :param TMults:
        :type TMults: TColStd_Array1OfInteger &
        :rtype: None

        """
        return _Approx.Approx_SweepApproximation_Curve2d(self, *args)


    def Curves2dDegree(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_SweepApproximation_Curves2dDegree(self, *args)


    def Curve2dPoles(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: TColgp_Array1OfPnt2d

        """
        return _Approx.Approx_SweepApproximation_Curve2dPoles(self, *args)


    def Curves2dKnots(self, *args):
        """
        :rtype: TColStd_Array1OfReal

        """
        return _Approx.Approx_SweepApproximation_Curves2dKnots(self, *args)


    def Curves2dMults(self, *args):
        """
        :rtype: TColStd_Array1OfInteger

        """
        return _Approx.Approx_SweepApproximation_Curves2dMults(self, *args)


    def Max2dError(self, *args):
        """
        * returns the maximum error of the <Index> 2d curve approximation.

        :param Index:
        :type Index: int
        :rtype: float

        """
        return _Approx.Approx_SweepApproximation_Max2dError(self, *args)


    def Average2dError(self, *args):
        """
        * returns the average error of the <Index> 2d curve approximation.

        :param Index:
        :type Index: int
        :rtype: float

        """
        return _Approx.Approx_SweepApproximation_Average2dError(self, *args)


    def TolCurveOnSurf(self, *args):
        """
        * returns the maximum 3d error of the <Index> 2d curve approximation on the Surface.

        :param Index:
        :type Index: int
        :rtype: float

        """
        return _Approx.Approx_SweepApproximation_TolCurveOnSurf(self, *args)


    def DumpToString(self):
        """DumpToString(Approx_SweepApproximation self) -> std::string"""
        return _Approx.Approx_SweepApproximation_DumpToString(self)


    def _kill_pointed(self):
        """_kill_pointed(Approx_SweepApproximation self)"""
        return _Approx.Approx_SweepApproximation__kill_pointed(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_SweepApproximation.Perform = new_instancemethod(_Approx.Approx_SweepApproximation_Perform, None, Approx_SweepApproximation)
Approx_SweepApproximation.Eval = new_instancemethod(_Approx.Approx_SweepApproximation_Eval, None, Approx_SweepApproximation)
Approx_SweepApproximation.IsDone = new_instancemethod(_Approx.Approx_SweepApproximation_IsDone, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfShape = new_instancemethod(_Approx.Approx_SweepApproximation_SurfShape, None, Approx_SweepApproximation)
Approx_SweepApproximation.Surface = new_instancemethod(_Approx.Approx_SweepApproximation_Surface, None, Approx_SweepApproximation)
Approx_SweepApproximation.UDegree = new_instancemethod(_Approx.Approx_SweepApproximation_UDegree, None, Approx_SweepApproximation)
Approx_SweepApproximation.VDegree = new_instancemethod(_Approx.Approx_SweepApproximation_VDegree, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfPoles = new_instancemethod(_Approx.Approx_SweepApproximation_SurfPoles, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfWeights = new_instancemethod(_Approx.Approx_SweepApproximation_SurfWeights, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfUKnots = new_instancemethod(_Approx.Approx_SweepApproximation_SurfUKnots, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfVKnots = new_instancemethod(_Approx.Approx_SweepApproximation_SurfVKnots, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfUMults = new_instancemethod(_Approx.Approx_SweepApproximation_SurfUMults, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfVMults = new_instancemethod(_Approx.Approx_SweepApproximation_SurfVMults, None, Approx_SweepApproximation)
Approx_SweepApproximation.MaxErrorOnSurf = new_instancemethod(_Approx.Approx_SweepApproximation_MaxErrorOnSurf, None, Approx_SweepApproximation)
Approx_SweepApproximation.AverageErrorOnSurf = new_instancemethod(_Approx.Approx_SweepApproximation_AverageErrorOnSurf, None, Approx_SweepApproximation)
Approx_SweepApproximation.NbCurves2d = new_instancemethod(_Approx.Approx_SweepApproximation_NbCurves2d, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dShape = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dShape, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curve2d = new_instancemethod(_Approx.Approx_SweepApproximation_Curve2d, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dDegree = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dDegree, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curve2dPoles = new_instancemethod(_Approx.Approx_SweepApproximation_Curve2dPoles, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dKnots = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dKnots, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dMults = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dMults, None, Approx_SweepApproximation)
Approx_SweepApproximation.Max2dError = new_instancemethod(_Approx.Approx_SweepApproximation_Max2dError, None, Approx_SweepApproximation)
Approx_SweepApproximation.Average2dError = new_instancemethod(_Approx.Approx_SweepApproximation_Average2dError, None, Approx_SweepApproximation)
Approx_SweepApproximation.TolCurveOnSurf = new_instancemethod(_Approx.Approx_SweepApproximation_TolCurveOnSurf, None, Approx_SweepApproximation)
Approx_SweepApproximation.DumpToString = new_instancemethod(_Approx.Approx_SweepApproximation_DumpToString, None, Approx_SweepApproximation)
Approx_SweepApproximation._kill_pointed = new_instancemethod(_Approx.Approx_SweepApproximation__kill_pointed, None, Approx_SweepApproximation)
Approx_SweepApproximation_swigregister = _Approx.Approx_SweepApproximation_swigregister
Approx_SweepApproximation_swigregister(Approx_SweepApproximation)

class Approx_SweepFunction(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def D0(self, *args):
        """
        * compute the section for v = param

        :param Param:
        :type Param: float
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_SweepFunction_D0(self, *args)


    def D1(self, *args):
        """
        * compute the first derivative in v direction of the section for v = param Warning : It used only for C1 or C2 aproximation

        :param Param:
        :type Param: float
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_SweepFunction_D1(self, *args)


    def D2(self, *args):
        """
        * compute the second derivative in v direction of the section for v = param Warning : It used only for C2 aproximation

        :param Param:
        :type Param: float
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_SweepFunction_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        * get the number of 2d curves to approximate.

        :rtype: int

        """
        return _Approx.Approx_SweepFunction_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        * get the format of an section

        :param NbPoles:
        :type NbPoles: int &
        :param NbKnots:
        :type NbKnots: int &
        :param Degree:
        :type Degree: int &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_SectionShape(self, *args)


    def Knots(self, *args):
        """
        * get the Knots of the section

        :param TKnots:
        :type TKnots: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_Knots(self, *args)


    def Mults(self, *args):
        """
        * get the Multplicities of the section

        :param TMults:
        :type TMults: TColStd_Array1OfInteger &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_Mults(self, *args)


    def IsRational(self, *args):
        """
        * Returns if the sections are rationnal or not

        :rtype: bool

        """
        return _Approx.Approx_SweepFunction_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>

        :param S:
        :type S: GeomAbs_Shape
        :rtype: int

        """
        return _Approx.Approx_SweepFunction_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>.  The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()

        :param T:
        :type T: TColStd_Array1OfReal &
        :param S:
        :type S: GeomAbs_Shape
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        * Sets the bounds of the parametric interval on the fonction This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_SetInterval(self, *args)


    def Resolution(self, *args):
        """
        * Returns the resolutions in the sub-space 2d <Index> This information is usfull to find an good tolerance in 2d approximation.

        :param Index:
        :type Index: int
        :param Tol:
        :type Tol: float
        :param TolU:
        :type TolU: float &
        :param TolV:
        :type TolV: float &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_Resolution(self, *args)


    def GetTolerance(self, *args):
        """
        * Returns the tolerance to reach in approximation to satisfy. BoundTol error at the Boundary AngleTol tangent error at the Boundary (in radian) SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        * Is usefull, if (me) have to run numerical algorithm to perform D0, D1 or D2

        :param Tol3d:
        :type Tol3d: float
        :param Tol2d:
        :type Tol2d: float
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        * Get the barycentre of Surface. An very poor estimation is sufficent. This information is usefull to perform well conditioned rational approximation. Warning: Used only if <self> IsRational

        :rtype: gp_Pnt

        """
        return _Approx.Approx_SweepFunction_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        * Returns the length of the greater section. This information is usefull to G1's control. Warning: With an little value, approximation can be slower.

        :rtype: float

        """
        return _Approx.Approx_SweepFunction_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        * Compute the minimal value of weight for each poles in all sections. This information is usefull to control error in rational approximation. Warning: Used only if <self> IsRational

        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_GetMinimalWeight(self, *args)


    def _kill_pointed(self):
        """_kill_pointed(Approx_SweepFunction self)"""
        return _Approx.Approx_SweepFunction__kill_pointed(self)


    def GetHandle(self):
        """GetHandle(Approx_SweepFunction self) -> Handle_Approx_SweepFunction"""
        return _Approx.Approx_SweepFunction_GetHandle(self)


    def __del__(self):
    	try:
    		self.thisown = False
    		GarbageCollector.garbage.collect_object(self)
    	except:
    		pass


Approx_SweepFunction.D0 = new_instancemethod(_Approx.Approx_SweepFunction_D0, None, Approx_SweepFunction)
Approx_SweepFunction.D1 = new_instancemethod(_Approx.Approx_SweepFunction_D1, None, Approx_SweepFunction)
Approx_SweepFunction.D2 = new_instancemethod(_Approx.Approx_SweepFunction_D2, None, Approx_SweepFunction)
Approx_SweepFunction.Nb2dCurves = new_instancemethod(_Approx.Approx_SweepFunction_Nb2dCurves, None, Approx_SweepFunction)
Approx_SweepFunction.SectionShape = new_instancemethod(_Approx.Approx_SweepFunction_SectionShape, None, Approx_SweepFunction)
Approx_SweepFunction.Knots = new_instancemethod(_Approx.Approx_SweepFunction_Knots, None, Approx_SweepFunction)
Approx_SweepFunction.Mults = new_instancemethod(_Approx.Approx_SweepFunction_Mults, None, Approx_SweepFunction)
Approx_SweepFunction.IsRational = new_instancemethod(_Approx.Approx_SweepFunction_IsRational, None, Approx_SweepFunction)
Approx_SweepFunction.NbIntervals = new_instancemethod(_Approx.Approx_SweepFunction_NbIntervals, None, Approx_SweepFunction)
Approx_SweepFunction.Intervals = new_instancemethod(_Approx.Approx_SweepFunction_Intervals, None, Approx_SweepFunction)
Approx_SweepFunction.SetInterval = new_instancemethod(_Approx.Approx_SweepFunction_SetInterval, None, Approx_SweepFunction)
Approx_SweepFunction.Resolution = new_instancemethod(_Approx.Approx_SweepFunction_Resolution, None, Approx_SweepFunction)
Approx_SweepFunction.GetTolerance = new_instancemethod(_Approx.Approx_SweepFunction_GetTolerance, None, Approx_SweepFunction)
Approx_SweepFunction.SetTolerance = new_instancemethod(_Approx.Approx_SweepFunction_SetTolerance, None, Approx_SweepFunction)
Approx_SweepFunction.BarycentreOfSurf = new_instancemethod(_Approx.Approx_SweepFunction_BarycentreOfSurf, None, Approx_SweepFunction)
Approx_SweepFunction.MaximalSection = new_instancemethod(_Approx.Approx_SweepFunction_MaximalSection, None, Approx_SweepFunction)
Approx_SweepFunction.GetMinimalWeight = new_instancemethod(_Approx.Approx_SweepFunction_GetMinimalWeight, None, Approx_SweepFunction)
Approx_SweepFunction._kill_pointed = new_instancemethod(_Approx.Approx_SweepFunction__kill_pointed, None, Approx_SweepFunction)
Approx_SweepFunction.GetHandle = new_instancemethod(_Approx.Approx_SweepFunction_GetHandle, None, Approx_SweepFunction)
Approx_SweepFunction_swigregister = _Approx.Approx_SweepFunction_swigregister
Approx_SweepFunction_swigregister(Approx_SweepFunction)

class Handle_Approx_SweepFunction(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Approx.Handle_Approx_SweepFunction_swiginit(self, _Approx.new_Handle_Approx_SweepFunction(*args))
    DownCast = staticmethod(_Approx.Handle_Approx_SweepFunction_DownCast)

    def __del__(self):
        try:
            self.thisown = False
            GarbageCollector.garbage.collect_object(self)
        except:
            pass


Handle_Approx_SweepFunction.Nullify = new_instancemethod(_Approx.Handle_Approx_SweepFunction_Nullify, None, Handle_Approx_SweepFunction)
Handle_Approx_SweepFunction.IsNull = new_instancemethod(_Approx.Handle_Approx_SweepFunction_IsNull, None, Handle_Approx_SweepFunction)
Handle_Approx_SweepFunction.GetObject = new_instancemethod(_Approx.Handle_Approx_SweepFunction_GetObject, None, Handle_Approx_SweepFunction)
Handle_Approx_SweepFunction._kill_pointed = new_instancemethod(_Approx.Handle_Approx_SweepFunction__kill_pointed, None, Handle_Approx_SweepFunction)
Handle_Approx_SweepFunction_swigregister = _Approx.Handle_Approx_SweepFunction_swigregister
Handle_Approx_SweepFunction_swigregister(Handle_Approx_SweepFunction)

def Handle_Approx_SweepFunction_DownCast(AnObject):
    return _Approx.Handle_Approx_SweepFunction_DownCast(AnObject)
Handle_Approx_SweepFunction_DownCast = _Approx.Handle_Approx_SweepFunction_DownCast



